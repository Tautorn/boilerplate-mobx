{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///react-maskedinput.min.js","webpack:///webpack/bootstrap 3abc07daad89752d2f2d","webpack:///./src/index.js","webpack:///./~/inputmask-core/lib/index.js","webpack:///external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_2__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_objectWithoutProperties","obj","keys","target","i","indexOf","Object","prototype","hasOwnProperty","_defineProperty","key","value","defineProperty","enumerable","configurable","writable","isUndo","e","ctrlKey","metaKey","keyCode","shiftKey","KEYCODE_Y","KEYCODE_Z","isRedo","getSelection","el","start","end","rangeEl","clone","undefined","selectionStart","selectionEnd","focus","createTextRange","duplicate","moveToBookmark","document","selection","createRange","getBookmark","setEndPoint","text","length","setSelection","setSelectionRange","collapse","moveStart","moveEnd","select","_extends","assign","arguments","source","React","InputMask","MaskedInput","createClass","displayName","propTypes","mask","PropTypes","string","isRequired","formatCharacters","object","placeholderChar","getDefaultProps","componentWillMount","options","pattern","props","componentWillReceiveProps","nextProps","getValue","emptyValue","setPattern","getRawValue","setValue","componentWillUpdate","nextState","_updatePattern","componentDidUpdate","prevProps","_updateInputSelection","input","_updateMaskSelection","_onChange","maskValue","sizeDiff","backspace","_getDisplayValue","onChange","_onKeyDown","preventDefault","undo","redo","_onKeyPress","altKey","data","_onPaste","paste","clipboardData","getData","setTimeout","_keyPressPropName","navigator","userAgent","match","_getEventHandlers","onKeyDown","onPaste","blur","render","_this","ref","r","maxLength","eventHandlers","_props","_props$size","size","_props$placeholder","placeholder","_props2","cleanedProps","inputProps","createElement","extend","dest","src","l","copy","mergeFormatCharacters","merged","DEFAULT_FORMAT_CHARACTERS","chars","char","Pattern","isRevealingMask","DEFAULT_PLACEHOLDER_CHAR","firstEditableIndex","lastEditableIndex","_editableIndices","_parse","Error","ESCAPE_CHAR","DIGIT_RE","LETTER_RE","ALPHANNUMERIC_RE","*","validate","test","1","a","A","transform","toUpperCase","#","sourceChars","split","patternIndex","push","formatValue","valueBuffer","Array","valueIndex","isEditableIndex","isValidAtIndex","index","format","selectionBefore","valueBefore","inputIndex","_historyIndex","_history","splice","_lastOp","_lastSelection","lastOp","initialState","slice","charAt","substring","valid","historyItem","startUndo","pop","join","_resetHistory","rawValue"],"mappings":";;;;CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,EAAAG,QAAA,UACA,kBAAAC,gBAAAC,IACAD,QAAA,SAAAJ,GACA,gBAAAC,SACAA,QAAA,YAAAD,EAAAG,QAAA,UAEAJ,EAAA,YAAAC,EAAAD,EAAA,QACCO,KAAA,SAAAC,GACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAT,OAGA,IAAAC,GAAAS,EAAAD,IACAT,WACAW,GAAAF,EACAG,QAAA,EAUA,OANAL,GAAAE,GAAAI,KAAAZ,EAAAD,QAAAC,IAAAD,QAAAQ,GAGAP,EAAAW,QAAA,EAGAX,EAAAD,QAvBA,GAAAU,KAqCA,OATAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,GAGAR,EAAA,KDgBM,SAASP,EAAQD,EAASQ,GAE/B,YAIA,SAASS,GAAyBC,EAAKC,GAAQ,GAAIC,KAAa,KAAK,GAAIC,KAAKH,GAAWC,EAAKG,QAAQD,IAAM,GAAkBE,OAAOC,UAAUC,eAAeZ,KAAKK,EAAKG,KAAcD,EAAOC,GAAKH,EAAIG,GAAM,OAAOD,GAEnN,QAASM,GAAgBR,EAAKS,EAAKC,GAAiK,MAApJD,KAAOT,GAAOK,OAAOM,eAAeX,EAAKS,GAAOC,MAAOA,EAAOE,YAAY,EAAMC,cAAc,EAAMC,UAAU,IAAkBd,EAAIS,GAAOC,EAAgBV,EExD5M,QAASe,GAAOC,GACd,OAAQA,EAAEC,SAAWD,EAAEE,UAAYF,EAAEG,WAAaH,EAAEI,SAAWC,EAAYC,GAG7E,QAASC,GAAOP,GACd,OAAQA,EAAEC,SAAWD,EAAEE,UAAYF,EAAEG,WAAaH,EAAEI,SAAWE,EAAYD,GAG7E,QAASG,GAAcC,GACrB,GAAIC,GAAOC,EAAKC,EAASC,CAEzB,IAA0BC,SAAtBL,EAAGM,eACLL,EAAQD,EAAGM,eACXJ,EAAMF,EAAGO,iBAGT,KACEP,EAAGQ,QACHL,EAAUH,EAAGS,kBACbL,EAAQD,EAAQO,YAEhBP,EAAQQ,eAAeC,SAASC,UAAUC,cAAcC,eACxDX,EAAMY,YAAY,aAAcb,GAEhCF,EAAQG,EAAMa,KAAKC,OACnBhB,EAAMD,EAAQE,EAAQc,KAAKC,OAE7B,MAAO3B,IAGT,OAASU,QAAOC,OAGlB,QAASiB,GAAanB,EAAIa,GACxB,GAAIV,EAEJ,KAC4BE,SAAtBL,EAAGM,gBACLN,EAAGQ,QACHR,EAAGoB,kBAAkBP,EAAUZ,MAAOY,EAAUX,OAGhDF,EAAGQ,QACHL,EAAUH,EAAGS,kBACbN,EAAQkB,UAAS,GACjBlB,EAAQmB,UAAU,YAAaT,EAAUZ,OACzCE,EAAQoB,QAAQ,YAAaV,EAAUX,IAAMW,EAAUZ,OACvDE,EAAQqB,UAGZ,MAAOjC,KFER,GAAIkC,GAAW7C,OAAO8C,QAAU,SAAUjD,GAAU,IAAK,GAAIC,GAAI,EAAGA,EAAIiD,UAAUT,OAAQxC,IAAK,CAAE,GAAIkD,GAASD,UAAUjD,EAAI,KAAK,GAAIM,KAAO4C,GAAchD,OAAOC,UAAUC,eAAeZ,KAAK0D,EAAQ5C,KAAQP,EAAOO,GAAO4C,EAAO5C,IAAY,MAAOP,IE1DpPoD,EAAQhE,EAAQ,GAChBiE,EAAYjE,EAAQ,GAEpBgC,EAAY,GACZD,EAAY,GAuDZmC,EAAcF,EAAMG,aF6DrBC,YAAa,cE5DdC,WACEC,KAAMN,EAAMO,UAAUC,OAAOC,WAE7BC,iBAAkBV,EAAMO,UAAUI,OAClCC,gBAAiBZ,EAAMO,UAAUC,QAGnCK,gBAAe,WACb,OACEzD,MAAO,KAIX0D,mBAAkB,WAChB,GAAIC,IACFC,QAASnF,KAAKoF,MAAMX,KACpBlD,MAAOvB,KAAKoF,MAAM7D,MAClBsD,iBAAkB7E,KAAKoF,MAAMP,iBAE3B7E,MAAKoF,MAAML,kBACbG,EAAQH,gBAAkB/E,KAAKoF,MAAML,iBAEvC/E,KAAKyE,KAAO,GAAIL,GAAUc,IAG5BG,0BAAyB,SAACC,GACpBtF,KAAKoF,MAAMX,OAASa,EAAUb,MAAQzE,KAAKoF,MAAM7D,QAAU+D,EAAUb,KAKnEzE,KAAKyE,KAAKc,aAAevF,KAAKyE,KAAKe,WACrCxF,KAAKyE,KAAKgB,WAAWH,EAAUb,MAAOlD,MAAO+D,EAAU/D,QAGvDvB,KAAKyE,KAAKgB,WAAWH,EAAUb,MAAOlD,MAAOvB,KAAKyE,KAAKiB,gBAGlD1F,KAAKoF,MAAMX,OAASa,EAAUb,KACrCzE,KAAKyE,KAAKgB,WAAWH,EAAUb,MAAOlD,MAAOvB,KAAKyE,KAAKiB,gBAEhD1F,KAAKoF,MAAM7D,QAAU+D,EAAU/D,OACtCvB,KAAKyE,KAAKkB,SAASL,EAAU/D,QAIjCqE,oBAAmB,SAACN,EAAWO,GACzBP,EAAUb,OAASzE,KAAKoF,MAAMX,MAChCzE,KAAK8F,eAAeR,IAIxBS,mBAAkB,SAACC,GACbA,EAAUvB,OAASzE,KAAKoF,MAAMX,MAAQzE,KAAKyE,KAAKtB,UAAUZ,OAC5DvC,KAAKiG,yBAITH,eAAgB,SAASV,GACvBpF,KAAKyE,KAAKgB,WAAWL,EAAMX,MACzBlD,MAAOvB,KAAKyE,KAAKiB,cACjBvC,UAAWd,EAAarC,KAAKkG,UAIjCC,qBAAoB,WAClBnG,KAAKyE,KAAKtB,UAAYd,EAAarC,KAAKkG,QAG1CD,sBAAqB,WACnBxC,EAAazD,KAAKkG,MAAOlG,KAAKyE,KAAKtB,YAGrCiD,UAAS,SAACvE,GAGR,GAAIwE,GAAYrG,KAAKyE,KAAKc,UAC1B,IAAI1D,EAAEd,OAAOQ,QAAU8E,EAAW,CAEhC,GAAIxE,EAAEd,OAAOQ,MAAMiC,OAAS6C,EAAU7C,OAAQ,CAC5C,GAAI8C,GAAWD,EAAU7C,OAAS3B,EAAEd,OAAOQ,MAAMiC,MACjDxD,MAAKmG,uBACLnG,KAAKyE,KAAKtB,UAAUX,IAAMxC,KAAKyE,KAAKtB,UAAUZ,MAAQ+D,EACtDtG,KAAKyE,KAAK8B,YAEZ,GAAIhF,GAAQvB,KAAKwG,kBACjB3E,GAAEd,OAAOQ,MAAQA,EACbA,GACFvB,KAAKiG,wBAGLjG,KAAKoF,MAAMqB,UACbzG,KAAKoF,MAAMqB,SAAS5E,IAIxB6E,WAAU,SAAC7E,GAGT,GAAID,EAAOC,GAST,MARAA,GAAE8E,sBACE3G,KAAKyE,KAAKmC,SACZ/E,EAAEd,OAAOQ,MAAQvB,KAAKwG,mBACtBxG,KAAKiG,wBACDjG,KAAKoF,MAAMqB,UACbzG,KAAKoF,MAAMqB,SAAS5E,IAKrB,IAAIO,EAAOP,GASd,MARAA,GAAE8E,sBACE3G,KAAKyE,KAAKoC,SACZhF,EAAEd,OAAOQ,MAAQvB,KAAKwG,mBACtBxG,KAAKiG,wBACDjG,KAAKoF,MAAMqB,UACbzG,KAAKoF,MAAMqB,SAAS5E,IAM1B,IAAc,cAAVA,EAAEP,MACJO,EAAE8E,iBACF3G,KAAKmG,uBACDnG,KAAKyE,KAAK8B,aAAa,CACzB,GAAIhF,GAAQvB,KAAKwG,kBACjB3E,GAAEd,OAAOQ,MAAQA,EACbA,GACFvB,KAAKiG,wBAEHjG,KAAKoF,MAAMqB,UACbzG,KAAKoF,MAAMqB,SAAS5E,KAM5BiF,YAAW,SAACjF,GAKNA,EAAEE,SAAWF,EAAEkF,QAAUlF,EAAEC,SAAqB,UAAVD,EAAEP,MAE5CO,EAAE8E,iBACF3G,KAAKmG,uBACDnG,KAAKyE,KAAKyB,MAAOrE,EAAEP,KAAOO,EAAEmF,QAC9BnF,EAAEd,OAAOQ,MAAQvB,KAAKyE,KAAKc,WAC3BvF,KAAKiG,wBACDjG,KAAKoF,MAAMqB,UACbzG,KAAKoF,MAAMqB,SAAS5E,MAK1BoF,SAAQ,SAACpF,GAGPA,EAAE8E,iBACF3G,KAAKmG,uBAEDnG,KAAKyE,KAAKyC,MAAMrF,EAAEsF,cAAcC,QAAQ,WAC1CvF,EAAEd,OAAOQ,MAAQvB,KAAKyE,KAAKc,WAE3B8B,WAAWrH,KAAKiG,sBAAuB,GACnCjG,KAAKoF,MAAMqB,UACbzG,KAAKoF,MAAMqB,SAAS5E,KAK1B2E,iBAAgB,WACd,GAAIjF,GAAQvB,KAAKyE,KAAKc,UACtB,OAAOhE,KAAUvB,KAAKyE,KAAKe,WAAa,GAAKjE,GAG/C+F,kBAAiB,WACf,MAAyB,mBAAdC,YACFA,UAAUC,UAAUC,MAAM,YAC/B,gBAGG,cAGTC,kBAAiB,WACf,MAAArG,IACEoF,SAAUzG,KAAKoG,UACfuB,UAAW3H,KAAK0G,WAChBkB,QAAS5H,KAAKiH,UACbjH,KAAKsH,oBAAsBtH,KAAK8G,cAIrChE,MAAK,WACH9C,KAAKkG,MAAMpD,SAGb+E,KAAI,WACF7H,KAAKkG,MAAM2B,QAGbC,OAAM,WF0DH,GAAIC,GAAQ/H,KEzDTgI,EAAM,SAAAC,GF4DP,ME5DYF,GAAK7B,MAAQ+B,GACxBC,EAAYlI,KAAKyE,KAAKU,QAAQ3B,OAC9BjC,EAAQvB,KAAKwG,mBACb2B,EAAgBnI,KAAK0H,oBF8DpBU,EE7D0DpI,KAAKoF,MF8D/DiD,EAAcD,EE9DbE,OAAI3F,SAAA0F,EAAGH,EAASG,EFgEjBE,EAAqBH,EEhEFI,cAAW7F,SAAA4F,EAAGvI,KAAKyE,KAAKe,WAAU+C,EFkErDE,EEhEsDzI,KAAKoF,MAArBsD,GAAvBD,EAAf1D,gBAAiC0D,EAAhB5D,iBAAiCjE,EAAA6H,GAAA,wCACnDE,EAAU5E,KAAQ2E,EAAiBP,GAAeH,MAAKE,YAAW3G,QAAO+G,OAAME,eACnF,OAAOrE,GAAAyE,cAAA,QAAWD,KAItB/I,GAAOD,QAAU0E,GFyEX,SAASzE,EAAQD,GG7VvB,YAEA,SAAAkJ,GAAAC,EAAAC,GACA,GAAAA,EAEA,OADA3D,GAAAlE,OAAAJ,KAAAiI,GACA/H,EAAA,EAAAgI,EAAA5D,EAAA5B,OAAqCxC,EAAAgI,EAAQhI,IAC7C8H,EAAA1D,EAAApE,IAAA+H,EAAA3D,EAAApE,GAGA,OAAA8H,GAGA,QAAAG,GAAApI,GACA,MAAAgI,MAAkBhI,GASlB,QAAAqI,GAAArE,GACA,GAAAsE,GAAAF,EAAAG,EACA,IAAAvE,EAEA,OADAwE,GAAAnI,OAAAJ,KAAA+D,GACA7D,EAAA,EAAAgI,EAAAK,EAAA7F,OAAqCxC,EAAAgI,EAAQhI,IAAA,CAC7C,GAAAsI,GAAAD,EAAArI,EACA,OAAA6D,EAAAyE,SACAH,GAAAG,GAGAH,EAAAG,GAAAzE,EAAAyE,GAIA,MAAAH,GAkCA,QAAAI,GAAArF,EAAAW,EAAAE,EAAAyE,GACA,MAAAxJ,gBAAAuJ,IAKAvJ,KAAA+E,mBAAA0E,EAEAzJ,KAAA6E,oBAAAuE,EAEApJ,KAAAkE,SAEAlE,KAAAmF,WAEAnF,KAAAwD,OAAA,EAEAxD,KAAA0J,mBAAA,KAEA1J,KAAA2J,kBAAA,KAEA3J,KAAA4J,oBAEA5J,KAAAwJ,oBAAA,MAEAxJ,MAAA6J,UAtBA,GAAAN,GAAArF,EAAAW,EAAAE,GAmHA,QAAAX,GAAAc,GACA,KAAAlF,eAAAoE,IAAqC,UAAAA,GAAAc,EAUrC,IATAA,EAAA2D,GACAhE,iBAAA,KACAM,QAAA,KACAqE,iBAAA,EACAzE,gBAAA0E,EACAtG,WAAgBZ,MAAA,EAAAC,IAAA,GAChBjB,MAAA,IACG2D,GAEH,MAAAA,EAAAC,QACA,SAAA2E,OAAA,yCAGA,oBAAA5E,GAAAH,iBAAAG,EAAAH,gBAAAvB,OAAA,EACA,SAAAsG,OAAA,8EAGA9J,MAAA+E,gBAAAG,EAAAH,gBACA/E,KAAA6E,iBAAAqE,EAAAhE,EAAAL,kBACA7E,KAAAyF,WAAAP,EAAAC,SACA5D,MAAA2D,EAAA3D,MACA4B,UAAA+B,EAAA/B,UACAqG,gBAAAtE,EAAAsE,kBA5KA,GAAAO,GAAA,KAEAC,EAAA,OACAC,EAAA,aACAC,EAAA,eAEAT,EAAA,IACAL,GACAe,KACAC,SAAA,SAAAd,GAA8B,MAAAY,GAAAG,KAAAf,KAE9BgB,GACAF,SAAA,SAAAd,GAA8B,MAAAU,GAAAK,KAAAf,KAE9BiB,GACAH,SAAA,SAAAd,GAA8B,MAAAW,GAAAI,KAAAf,KAE9BkB,GACAJ,SAAA,SAAAd,GAA8B,MAAAW,GAAAI,KAAAf,IAC9BmB,UAAA,SAAAnB,GAA+B,MAAAA,GAAAoB,gBAE/BC,KACAP,SAAA,SAAAd,GAA8B,MAAAY,GAAAG,KAAAf,IAC9BmB,UAAA,SAAAnB,GAA+B,MAAAA,GAAAoB,gBAmC/BnB,GAAApI,UAAA0I,OAAA,WAKA,OAJAe,GAAA5K,KAAAkE,OAAA2G,MAAA,IACAC,EAAA,EACA3F,KAEAnE,EAAA,EAAAgI,EAAA4B,EAAApH,OAAyCxC,EAAAgI,EAAOhI,IAAA,CAChD,GAAAsI,GAAAsB,EAAA5J,EACA,IAAAsI,IAAAS,EAAA,CACA,GAAA/I,IAAAgI,EAAA,EACA,SAAAc,OAAA,sCAAAC,EAEAT,GAAAsB,IAAA5J,OAEAsI,KAAAtJ,MAAA6E,mBACA,OAAA7E,KAAA0J,qBACA1J,KAAA0J,mBAAAoB,GAEA9K,KAAA2J,kBAAAmB,EACA9K,KAAA4J,iBAAAkB,IAAA,EAGA3F,GAAA4F,KAAAzB,GACAwB,IAGA,UAAA9K,KAAA0J,mBACA,SAAAI,OACA,uBAAA9J,KAAAkE,OAAA,8CAIAlE,MAAAmF,UACAnF,KAAAwD,OAAA2B,EAAA3B,QAOA+F,EAAApI,UAAA6J,YAAA,SAAAzJ,GAIA,OAHA0J,GAAA,GAAAC,OAAAlL,KAAAwD,QACA2H,EAAA,EAEAnK,EAAA,EAAAgI,EAAAhJ,KAAAwD,OAAkCxC,EAAAgI,EAAQhI,IAC1C,GAAAhB,KAAAoL,gBAAApK,GAAA,CACA,GAAAhB,KAAAwJ,iBACAjI,EAAAiC,QAAA2H,IACAnL,KAAAqL,eAAA9J,EAAA4J,GAAAnK,GACA,KAEAiK,GAAAjK,GAAAO,EAAAiC,OAAA2H,GAAAnL,KAAAqL,eAAA9J,EAAA4J,GAAAnK,GACAhB,KAAAyK,UAAAlJ,EAAA4J,GAAAnK,GACAhB,KAAA+E,gBACAoG,QAGAF,GAAAjK,GAAAhB,KAAAmF,QAAAnE,GAGAO,EAAAiC,OAAA2H,GAAA5J,EAAA4J,KAAAnL,KAAAmF,QAAAnE,IACAmK,GAKA,OAAAF,IAOA1B,EAAApI,UAAAiK,gBAAA,SAAAE,GACA,QAAAtL,KAAA4J,iBAAA0B,IAQA/B,EAAApI,UAAAkK,eAAA,SAAA/B,EAAAgC,GACA,MAAAtL,MAAA6E,iBAAA7E,KAAAmF,QAAAmG,IAAAlB,SAAAd,IAGAC,EAAApI,UAAAsJ,UAAA,SAAAnB,EAAAgC,GACA,GAAAC,GAAAvL,KAAA6E,iBAAA7E,KAAAmF,QAAAmG,GACA,yBAAAC,GAAAd,UAAAc,EAAAd,UAAAnB,MAuCAlF,EAAAjD,UAAA+E,MAAA,SAAAoD,GAEA,GAAAtJ,KAAAmD,UAAAZ,QAAAvC,KAAAmD,UAAAX,KACAxC,KAAAmD,UAAAZ,QAAAvC,KAAAmF,QAAA3B,OACA,QAGA,IAAAgI,GAAAvC,EAAAjJ,KAAAmD,WACAsI,EAAAzL,KAAAuF,WAEAmG,EAAA1L,KAAAmD,UAAAZ,KASA,IALAmJ,EAAA1L,KAAAmF,QAAAuE,qBACAgC,EAAA1L,KAAAmF,QAAAuE,oBAIA1J,KAAAmF,QAAAiG,gBAAAM,GAAA,CACA,IAAA1L,KAAAmF,QAAAkG,eAAA/B,EAAAoC,GACA,QAEA1L,MAAAuB,MAAAmK,GAAA1L,KAAAmF,QAAAsF,UAAAnB,EAAAoC,GAMA,IADA,GAAAlJ,GAAAxC,KAAAmD,UAAAX,IAAA,EACAA,EAAAkJ,GACA1L,KAAAmF,QAAAiG,gBAAA5I,KACAxC,KAAAuB,MAAAiB,GAAAxC,KAAA+E,iBAEAvC,GAOA,KAHAxC,KAAAmD,UAAAZ,MAAAvC,KAAAmD,UAAAX,IAAAkJ,EAAA,EAGA1L,KAAAmF,QAAA3B,OAAAxD,KAAAmD,UAAAZ,QACAvC,KAAAmF,QAAAiG,gBAAApL,KAAAmD,UAAAZ,QACAvC,KAAAmD,UAAAZ,QACAvC,KAAAmD,UAAAX,KAiBA,OAbA,OAAAxC,KAAA2L,gBAEA3L,KAAA4L,SAAAC,OAAA7L,KAAA2L,cAAA3L,KAAA4L,SAAApI,OAAAxD,KAAA2L,eACA3L,KAAA2L,cAAA,OAEA,UAAA3L,KAAA8L,SACAN,EAAAjJ,QAAAiJ,EAAAhJ,KACA,OAAAxC,KAAA+L,gBAAAP,EAAAjJ,QAAAvC,KAAA+L,eAAAxJ,QACAvC,KAAA4L,SAAAb,MAAwBxJ,MAAAkK,EAAAtI,UAAAqI,EAAAQ,OAAAhM,KAAA8L,UAExB9L,KAAA8L,QAAA,QACA9L,KAAA+L,eAAA9C,EAAAjJ,KAAAmD,YAEA,GASAiB,EAAAjD,UAAAoF,UAAA,WAEA,OAAAvG,KAAAmD,UAAAZ,OAAA,IAAAvC,KAAAmD,UAAAX,IACA,QAGA,IAAAgJ,GAAAvC,EAAAjJ,KAAAmD,WACAsI,EAAAzL,KAAAuF,UAGA,IAAAvF,KAAAmD,UAAAZ,QAAAvC,KAAAmD,UAAAX,IACAxC,KAAAmF,QAAAiG,gBAAApL,KAAAmD,UAAAZ,MAAA,KACAvC,KAAAuB,MAAAvB,KAAAmD,UAAAZ,MAAA,GAAAvC,KAAA+E,iBAEA/E,KAAAmD,UAAAZ,QACAvC,KAAAmD,UAAAX,UAGA,CAEA,IADA,GAAAA,GAAAxC,KAAAmD,UAAAX,IAAA,EACAA,GAAAxC,KAAAmD,UAAAZ,OACAvC,KAAAmF,QAAAiG,gBAAA5I,KACAxC,KAAAuB,MAAAiB,GAAAxC,KAAA+E,iBAEAvC,GAEAxC,MAAAmD,UAAAX,IAAAxC,KAAAmD,UAAAZ,MAgBA,MAZA,OAAAvC,KAAA2L,eAEA3L,KAAA4L,SAAAC,OAAA7L,KAAA2L,cAAA3L,KAAA4L,SAAApI,OAAAxD,KAAA2L,gBAEA,cAAA3L,KAAA8L,SACAN,EAAAjJ,QAAAiJ,EAAAhJ,KACA,OAAAxC,KAAA+L,gBAAAP,EAAAjJ,QAAAvC,KAAA+L,eAAAxJ,QACAvC,KAAA4L,SAAAb,MAAwBxJ,MAAAkK,EAAAtI,UAAAqI,EAAAQ,OAAAhM,KAAA8L,UAExB9L,KAAA8L,QAAA,YACA9L,KAAA+L,eAAA9C,EAAAjJ,KAAAmD,YAEA,GAWAiB,EAAAjD,UAAA+F,MAAA,SAAAhB,GAGA,GAAA+F,IACA1K,MAAAvB,KAAAuB,MAAA2K,QACA/I,UAAA8F,EAAAjJ,KAAAmD,WACA2I,QAAA9L,KAAA8L,QACAF,SAAA5L,KAAA4L,SAAAM,QACAP,cAAA3L,KAAA2L,cACAI,eAAA9C,EAAAjJ,KAAA+L,gBAMA,IAAA/L,KAAAmD,UAAAZ,MAAAvC,KAAAmF,QAAAuE,mBAAA,CACA,OAAA1I,GAAA,EAAAgI,EAAAhJ,KAAAmF,QAAAuE,mBAAA1J,KAAAmD,UAAAZ,MAA+EvB,EAAAgI,EAAOhI,IACtF,GAAAkF,EAAAiG,OAAAnL,KAAAhB,KAAAmF,gBAAAnE,GACA,QAMAkF,KAAAkG,UAAApM,KAAAmF,QAAAuE,mBAAA1J,KAAAmD,UAAAZ,OACAvC,KAAAmD,UAAAZ,MAAAvC,KAAAmF,QAAAuE,mBAGA,IAAA1I,EAAA,EAAAgI,EAAA9C,EAAA1C,OACAxC,EAAAgI,GAAAhJ,KAAAmD,UAAAZ,OAAAvC,KAAAmF,QAAAwE,kBACA3I,IAAA,CACA,GAAAqL,GAAArM,KAAAkG,QAAAiG,OAAAnL,GAIA,KAAAqL,EAAA,CACA,GAAArM,KAAAmD,UAAAZ,MAAA,GAEA,GAAAuI,GAAA9K,KAAAmD,UAAAZ,MAAA,CACA,KAAAvC,KAAAmF,QAAAiG,gBAAAN,IACA5E,EAAAiG,OAAAnL,KAAAhB,KAAAmF,gBAAA2F,GACA,SAIA,MADAjC,GAAA7I,KAAAiM,IACA,GAIA,UAKA7H,EAAAjD,UAAAyF,KAAA,WAEA,OAAA5G,KAAA4L,SAAApI,QAAA,IAAAxD,KAAA2L,cACA,QAGA,IAAAW,EACA,UAAAtM,KAAA2L,cAAA,CAEA3L,KAAA2L,cAAA3L,KAAA4L,SAAApI,OAAA,EACA8I,EAAAtM,KAAA4L,SAAA5L,KAAA2L,cAGA,IAAApK,GAAAvB,KAAAuF,UACA+G,GAAA/K,WACA+K,EAAAnJ,UAAAZ,QAAAvC,KAAAmD,UAAAZ,OACA+J,EAAAnJ,UAAAX,MAAAxC,KAAAmD,UAAAX,KACAxC,KAAA4L,SAAAb,MAA0BxJ,QAAA4B,UAAA8F,EAAAjJ,KAAAmD,WAAA6I,OAAAhM,KAAA8L,QAAAS,WAAA,QAI1BD,GAAAtM,KAAA4L,WAAA5L,KAAA2L,cAMA,OAHA3L,MAAAuB,MAAA+K,EAAA/K,MAAAsJ,MAAA,IACA7K,KAAAmD,UAAAmJ,EAAAnJ,UACAnD,KAAA8L,QAAAQ,EAAAN,QACA,GAGA5H,EAAAjD,UAAA0F,KAAA,WACA,OAAA7G,KAAA4L,SAAApI,QAAA,MAAAxD,KAAA2L,cACA,QAEA,IAAAW,GAAAtM,KAAA4L,WAAA5L,KAAA2L,cAYA,OAVA3L,MAAA2L,gBAAA3L,KAAA4L,SAAApI,OAAA,IACAxD,KAAA2L,cAAA,KAEAW,EAAAC,WACAvM,KAAA4L,SAAAY,OAGAxM,KAAAuB,MAAA+K,EAAA/K,MAAAsJ,MAAA,IACA7K,KAAAmD,UAAAmJ,EAAAnJ,UACAnD,KAAA8L,QAAAQ,EAAAN,QACA,GAKA5H,EAAAjD,UAAAsE,WAAA,SAAAN,EAAAD,GACAA,EAAA2D,GACA1F,WAAgBZ,MAAA,EAAAC,IAAA,GAChBjB,MAAA,IACG2D,GACHlF,KAAAmF,QAAA,GAAAoE,GAAApE,EAAAnF,KAAA6E,iBAAA7E,KAAA+E,gBAAAG,EAAAsE,iBACAxJ,KAAA2F,SAAAT,EAAA3D,OACAvB,KAAAwF,WAAAxF,KAAAmF,QAAA6F,gBAAAyB,KAAA,IACAzM,KAAAmD,UAAA+B,EAAA/B,UACAnD,KAAA0M,iBAGAtI,EAAAjD,UAAAsC,aAAA,SAAAN,GAEA,GADAnD,KAAAmD,UAAA8F,EAAA9F,GACAnD,KAAAmD,UAAAZ,QAAAvC,KAAAmD,UAAAX,IAAA,CACA,GAAAxC,KAAAmD,UAAAZ,MAAAvC,KAAAmF,QAAAuE,mBAEA,MADA1J,MAAAmD,UAAAZ,MAAAvC,KAAAmD,UAAAX,IAAAxC,KAAAmF,QAAAuE,oBACA,CAKA,KADA,GAAA4B,GAAAtL,KAAAmD,UAAAZ,MACA+I,GAAAtL,KAAAmF,QAAAuE,oBAAA,CACA,GAAA1J,KAAAmF,QAAAiG,gBAAAE,EAAA,IACAtL,KAAAuB,MAAA+J,EAAA,KAAAtL,KAAA+E,iBACAuG,IAAAtL,KAAAmF,QAAAuE,mBAAA,CACA1J,KAAAmD,UAAAZ,MAAAvC,KAAAmD,UAAAX,IAAA8I,CACA,OAEAA,IAEA,SAEA,UAGAlH,EAAAjD,UAAAwE,SAAA,SAAApE,GACA,MAAAA,IACAA,EAAA,IAEAvB,KAAAuB,MAAAvB,KAAAmF,QAAA6F,YAAAzJ,EAAAsJ,MAAA,MAGAzG,EAAAjD,UAAAoE,SAAA,WACA,MAAAvF,MAAAuB,MAAAkL,KAAA,KAGArI,EAAAjD,UAAAuE,YAAA,WAEA,OADAiH,MACA3L,EAAA,EAAiBA,EAAAhB,KAAAuB,MAAAiC,OAAuBxC,IACxChB,KAAAmF,QAAAyE,iBAAA5I,MAAA,GACA2L,EAAA5B,KAAA/K,KAAAuB,MAAAP,GAGA,OAAA2L,GAAAF,KAAA,KAGArI,EAAAjD,UAAAuL,cAAA,WACA1M,KAAA4L,YACA5L,KAAA2L,cAAA,KACA3L,KAAA8L,QAAA,KACA9L,KAAA+L,eAAA9C,EAAAjJ,KAAAmD,YAGAiB,EAAAmF,UAEA3J,EAAAD,QAAAyE,GHoWM,SAASxE,EAAQD,GIx2BvBC,EAAAD,QAAAM","file":"react-maskedinput.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"MaskedInput\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"MaskedInput\"] = factory(root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"MaskedInput\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"MaskedInput\"] = factory(root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\tvar React = __webpack_require__(2);\n\tvar InputMask = __webpack_require__(1);\n\t\n\tvar KEYCODE_Z = 90;\n\tvar KEYCODE_Y = 89;\n\t\n\tfunction isUndo(e) {\n\t  return (e.ctrlKey || e.metaKey) && e.keyCode === (e.shiftKey ? KEYCODE_Y : KEYCODE_Z);\n\t}\n\t\n\tfunction isRedo(e) {\n\t  return (e.ctrlKey || e.metaKey) && e.keyCode === (e.shiftKey ? KEYCODE_Z : KEYCODE_Y);\n\t}\n\t\n\tfunction getSelection(el) {\n\t  var start, end, rangeEl, clone;\n\t\n\t  if (el.selectionStart !== undefined) {\n\t    start = el.selectionStart;\n\t    end = el.selectionEnd;\n\t  } else {\n\t    try {\n\t      el.focus();\n\t      rangeEl = el.createTextRange();\n\t      clone = rangeEl.duplicate();\n\t\n\t      rangeEl.moveToBookmark(document.selection.createRange().getBookmark());\n\t      clone.setEndPoint('EndToStart', rangeEl);\n\t\n\t      start = clone.text.length;\n\t      end = start + rangeEl.text.length;\n\t    } catch (e) {/* not focused or not visible */}\n\t  }\n\t\n\t  return { start: start, end: end };\n\t}\n\t\n\tfunction setSelection(el, selection) {\n\t  var rangeEl;\n\t\n\t  try {\n\t    if (el.selectionStart !== undefined) {\n\t      el.focus();\n\t      el.setSelectionRange(selection.start, selection.end);\n\t    } else {\n\t      el.focus();\n\t      rangeEl = el.createTextRange();\n\t      rangeEl.collapse(true);\n\t      rangeEl.moveStart('character', selection.start);\n\t      rangeEl.moveEnd('character', selection.end - selection.start);\n\t      rangeEl.select();\n\t    }\n\t  } catch (e) {/* not focused or not visible */}\n\t}\n\t\n\tvar MaskedInput = React.createClass({\n\t  displayName: 'MaskedInput',\n\t\n\t  propTypes: {\n\t    mask: React.PropTypes.string.isRequired,\n\t\n\t    formatCharacters: React.PropTypes.object,\n\t    placeholderChar: React.PropTypes.string\n\t  },\n\t\n\t  getDefaultProps: function getDefaultProps() {\n\t    return {\n\t      value: ''\n\t    };\n\t  },\n\t\n\t  componentWillMount: function componentWillMount() {\n\t    var options = {\n\t      pattern: this.props.mask,\n\t      value: this.props.value,\n\t      formatCharacters: this.props.formatCharacters\n\t    };\n\t    if (this.props.placeholderChar) {\n\t      options.placeholderChar = this.props.placeholderChar;\n\t    }\n\t    this.mask = new InputMask(options);\n\t  },\n\t\n\t  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {\n\t    if (this.props.mask !== nextProps.mask && this.props.value !== nextProps.mask) {\n\t      // if we get a new value and a new mask at the same time\n\t      // check if the mask.value is still the initial value\n\t      // - if so use the nextProps value\n\t      // - otherwise the `this.mask` has a value for us (most likely from paste action)\n\t      if (this.mask.getValue() === this.mask.emptyValue) {\n\t        this.mask.setPattern(nextProps.mask, { value: nextProps.value });\n\t      } else {\n\t        this.mask.setPattern(nextProps.mask, { value: this.mask.getRawValue() });\n\t      }\n\t    } else if (this.props.mask !== nextProps.mask) {\n\t      this.mask.setPattern(nextProps.mask, { value: this.mask.getRawValue() });\n\t    } else if (this.props.value !== nextProps.value) {\n\t      this.mask.setValue(nextProps.value);\n\t    }\n\t  },\n\t\n\t  componentWillUpdate: function componentWillUpdate(nextProps, nextState) {\n\t    if (nextProps.mask !== this.props.mask) {\n\t      this._updatePattern(nextProps);\n\t    }\n\t  },\n\t\n\t  componentDidUpdate: function componentDidUpdate(prevProps) {\n\t    if (prevProps.mask !== this.props.mask && this.mask.selection.start) {\n\t      this._updateInputSelection();\n\t    }\n\t  },\n\t\n\t  _updatePattern: function _updatePattern(props) {\n\t    this.mask.setPattern(props.mask, {\n\t      value: this.mask.getRawValue(),\n\t      selection: getSelection(this.input)\n\t    });\n\t  },\n\t\n\t  _updateMaskSelection: function _updateMaskSelection() {\n\t    this.mask.selection = getSelection(this.input);\n\t  },\n\t\n\t  _updateInputSelection: function _updateInputSelection() {\n\t    setSelection(this.input, this.mask.selection);\n\t  },\n\t\n\t  _onChange: function _onChange(e) {\n\t    // console.log('onChange', JSON.stringify(getSelection(this.input)), e.target.value)\n\t\n\t    var maskValue = this.mask.getValue();\n\t    if (e.target.value !== maskValue) {\n\t      // Cut or delete operations will have shortened the value\n\t      if (e.target.value.length < maskValue.length) {\n\t        var sizeDiff = maskValue.length - e.target.value.length;\n\t        this._updateMaskSelection();\n\t        this.mask.selection.end = this.mask.selection.start + sizeDiff;\n\t        this.mask.backspace();\n\t      }\n\t      var value = this._getDisplayValue();\n\t      e.target.value = value;\n\t      if (value) {\n\t        this._updateInputSelection();\n\t      }\n\t    }\n\t    if (this.props.onChange) {\n\t      this.props.onChange(e);\n\t    }\n\t  },\n\t\n\t  _onKeyDown: function _onKeyDown(e) {\n\t    // console.log('onKeyDown', JSON.stringify(getSelection(this.input)), e.key, e.target.value)\n\t\n\t    if (isUndo(e)) {\n\t      e.preventDefault();\n\t      if (this.mask.undo()) {\n\t        e.target.value = this._getDisplayValue();\n\t        this._updateInputSelection();\n\t        if (this.props.onChange) {\n\t          this.props.onChange(e);\n\t        }\n\t      }\n\t      return;\n\t    } else if (isRedo(e)) {\n\t      e.preventDefault();\n\t      if (this.mask.redo()) {\n\t        e.target.value = this._getDisplayValue();\n\t        this._updateInputSelection();\n\t        if (this.props.onChange) {\n\t          this.props.onChange(e);\n\t        }\n\t      }\n\t      return;\n\t    }\n\t\n\t    if (e.key === 'Backspace') {\n\t      e.preventDefault();\n\t      this._updateMaskSelection();\n\t      if (this.mask.backspace()) {\n\t        var value = this._getDisplayValue();\n\t        e.target.value = value;\n\t        if (value) {\n\t          this._updateInputSelection();\n\t        }\n\t        if (this.props.onChange) {\n\t          this.props.onChange(e);\n\t        }\n\t      }\n\t    }\n\t  },\n\t\n\t  _onKeyPress: function _onKeyPress(e) {\n\t    // console.log('onKeyPress', JSON.stringify(getSelection(this.input)), e.key, e.target.value)\n\t\n\t    // Ignore modified key presses\n\t    // Ignore enter key to allow form submission\n\t    if (e.metaKey || e.altKey || e.ctrlKey || e.key === 'Enter') {\n\t      return;\n\t    }\n\t\n\t    e.preventDefault();\n\t    this._updateMaskSelection();\n\t    if (this.mask.input(e.key || e.data)) {\n\t      e.target.value = this.mask.getValue();\n\t      this._updateInputSelection();\n\t      if (this.props.onChange) {\n\t        this.props.onChange(e);\n\t      }\n\t    }\n\t  },\n\t\n\t  _onPaste: function _onPaste(e) {\n\t    // console.log('onPaste', JSON.stringify(getSelection(this.input)), e.clipboardData.getData('Text'), e.target.value)\n\t\n\t    e.preventDefault();\n\t    this._updateMaskSelection();\n\t    // getData value needed for IE also works in FF & Chrome\n\t    if (this.mask.paste(e.clipboardData.getData('Text'))) {\n\t      e.target.value = this.mask.getValue();\n\t      // Timeout needed for IE\n\t      setTimeout(this._updateInputSelection, 0);\n\t      if (this.props.onChange) {\n\t        this.props.onChange(e);\n\t      }\n\t    }\n\t  },\n\t\n\t  _getDisplayValue: function _getDisplayValue() {\n\t    var value = this.mask.getValue();\n\t    return value === this.mask.emptyValue ? '' : value;\n\t  },\n\t\n\t  _keyPressPropName: function _keyPressPropName() {\n\t    if (typeof navigator !== 'undefined') {\n\t      return navigator.userAgent.match(/Android/i) ? 'onBeforeInput' : 'onKeyPress';\n\t    }\n\t    return 'onKeyPress';\n\t  },\n\t\n\t  _getEventHandlers: function _getEventHandlers() {\n\t    return _defineProperty({\n\t      onChange: this._onChange,\n\t      onKeyDown: this._onKeyDown,\n\t      onPaste: this._onPaste\n\t    }, this._keyPressPropName(), this._onKeyPress);\n\t  },\n\t\n\t  focus: function focus() {\n\t    this.input.focus();\n\t  },\n\t\n\t  blur: function blur() {\n\t    this.input.blur();\n\t  },\n\t\n\t  render: function render() {\n\t    var _this = this;\n\t\n\t    var ref = function ref(r) {\n\t      return _this.input = r;\n\t    };\n\t    var maxLength = this.mask.pattern.length;\n\t    var value = this._getDisplayValue();\n\t    var eventHandlers = this._getEventHandlers();\n\t    var _props = this.props;\n\t    var _props$size = _props.size;\n\t    var size = _props$size === undefined ? maxLength : _props$size;\n\t    var _props$placeholder = _props.placeholder;\n\t    var placeholder = _props$placeholder === undefined ? this.mask.emptyValue : _props$placeholder;\n\t    var _props2 = this.props;\n\t    var placeholderChar = _props2.placeholderChar;\n\t    var formatCharacters = _props2.formatCharacters;\n\t\n\t    var cleanedProps = _objectWithoutProperties(_props2, ['placeholderChar', 'formatCharacters']);\n\t\n\t    var inputProps = _extends({}, cleanedProps, eventHandlers, { ref: ref, maxLength: maxLength, value: value, size: size, placeholder: placeholder });\n\t    return React.createElement('input', inputProps);\n\t  }\n\t});\n\t\n\tmodule.exports = MaskedInput;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict'\n\t\n\tfunction extend(dest, src) {\n\t  if (src) {\n\t    var props = Object.keys(src)\n\t    for (var i = 0, l = props.length; i < l ; i++) {\n\t      dest[props[i]] = src[props[i]]\n\t    }\n\t  }\n\t  return dest\n\t}\n\t\n\tfunction copy(obj) {\n\t  return extend({}, obj)\n\t}\n\t\n\t/**\n\t * Merge an object defining format characters into the defaults.\n\t * Passing null/undefined for en existing format character removes it.\n\t * Passing a definition for an existing format character overrides it.\n\t * @param {?Object} formatCharacters.\n\t */\n\tfunction mergeFormatCharacters(formatCharacters) {\n\t  var merged = copy(DEFAULT_FORMAT_CHARACTERS)\n\t  if (formatCharacters) {\n\t    var chars = Object.keys(formatCharacters)\n\t    for (var i = 0, l = chars.length; i < l ; i++) {\n\t      var char = chars[i]\n\t      if (formatCharacters[char] == null) {\n\t        delete merged[char]\n\t      }\n\t      else {\n\t        merged[char] = formatCharacters[char]\n\t      }\n\t    }\n\t  }\n\t  return merged\n\t}\n\t\n\tvar ESCAPE_CHAR = '\\\\'\n\t\n\tvar DIGIT_RE = /^\\d$/\n\tvar LETTER_RE = /^[A-Za-z]$/\n\tvar ALPHANNUMERIC_RE = /^[\\dA-Za-z]$/\n\t\n\tvar DEFAULT_PLACEHOLDER_CHAR = '_'\n\tvar DEFAULT_FORMAT_CHARACTERS = {\n\t  '*': {\n\t    validate: function(char) { return ALPHANNUMERIC_RE.test(char) }\n\t  },\n\t  '1': {\n\t    validate: function(char) { return DIGIT_RE.test(char) }\n\t  },\n\t  'a': {\n\t    validate: function(char) { return LETTER_RE.test(char) }\n\t  },\n\t  'A': {\n\t    validate: function(char) { return LETTER_RE.test(char) },\n\t    transform: function(char) { return char.toUpperCase() }\n\t  },\n\t  '#': {\n\t    validate: function(char) { return ALPHANNUMERIC_RE.test(char) },\n\t    transform: function(char) { return char.toUpperCase() }\n\t  }\n\t}\n\t\n\t/**\n\t * @param {string} source\n\t * @patam {?Object} formatCharacters\n\t */\n\tfunction Pattern(source, formatCharacters, placeholderChar, isRevealingMask) {\n\t  if (!(this instanceof Pattern)) {\n\t    return new Pattern(source, formatCharacters, placeholderChar)\n\t  }\n\t\n\t  /** Placeholder character */\n\t  this.placeholderChar = placeholderChar || DEFAULT_PLACEHOLDER_CHAR\n\t  /** Format character definitions. */\n\t  this.formatCharacters = formatCharacters || DEFAULT_FORMAT_CHARACTERS\n\t  /** Pattern definition string with escape characters. */\n\t  this.source = source\n\t  /** Pattern characters after escape characters have been processed. */\n\t  this.pattern = []\n\t  /** Length of the pattern after escape characters have been processed. */\n\t  this.length = 0\n\t  /** Index of the first editable character. */\n\t  this.firstEditableIndex = null\n\t  /** Index of the last editable character. */\n\t  this.lastEditableIndex = null\n\t  /** Lookup for indices of editable characters in the pattern. */\n\t  this._editableIndices = {}\n\t  /** If true, only the pattern before the last valid value character shows. */\n\t  this.isRevealingMask = isRevealingMask || false\n\t\n\t  this._parse()\n\t}\n\t\n\tPattern.prototype._parse = function parse() {\n\t  var sourceChars = this.source.split('')\n\t  var patternIndex = 0\n\t  var pattern = []\n\t\n\t  for (var i = 0, l = sourceChars.length; i < l; i++) {\n\t    var char = sourceChars[i]\n\t    if (char === ESCAPE_CHAR) {\n\t      if (i === l - 1) {\n\t        throw new Error('InputMask: pattern ends with a raw ' + ESCAPE_CHAR)\n\t      }\n\t      char = sourceChars[++i]\n\t    }\n\t    else if (char in this.formatCharacters) {\n\t      if (this.firstEditableIndex === null) {\n\t        this.firstEditableIndex = patternIndex\n\t      }\n\t      this.lastEditableIndex = patternIndex\n\t      this._editableIndices[patternIndex] = true\n\t    }\n\t\n\t    pattern.push(char)\n\t    patternIndex++\n\t  }\n\t\n\t  if (this.firstEditableIndex === null) {\n\t    throw new Error(\n\t      'InputMask: pattern \"' + this.source + '\" does not contain any editable characters.'\n\t    )\n\t  }\n\t\n\t  this.pattern = pattern\n\t  this.length = pattern.length\n\t}\n\t\n\t/**\n\t * @param {Array<string>} value\n\t * @return {Array<string>}\n\t */\n\tPattern.prototype.formatValue = function format(value) {\n\t  var valueBuffer = new Array(this.length)\n\t  var valueIndex = 0\n\t\n\t  for (var i = 0, l = this.length; i < l ; i++) {\n\t    if (this.isEditableIndex(i)) {\n\t      if (this.isRevealingMask &&\n\t          value.length <= valueIndex &&\n\t          !this.isValidAtIndex(value[valueIndex], i)) {\n\t        break\n\t      }\n\t      valueBuffer[i] = (value.length > valueIndex && this.isValidAtIndex(value[valueIndex], i)\n\t                        ? this.transform(value[valueIndex], i)\n\t                        : this.placeholderChar)\n\t      valueIndex++\n\t    }\n\t    else {\n\t      valueBuffer[i] = this.pattern[i]\n\t      // Also allow the value to contain static values from the pattern by\n\t      // advancing its index.\n\t      if (value.length > valueIndex && value[valueIndex] === this.pattern[i]) {\n\t        valueIndex++\n\t      }\n\t    }\n\t  }\n\t\n\t  return valueBuffer\n\t}\n\t\n\t/**\n\t * @param {number} index\n\t * @return {boolean}\n\t */\n\tPattern.prototype.isEditableIndex = function isEditableIndex(index) {\n\t  return !!this._editableIndices[index]\n\t}\n\t\n\t/**\n\t * @param {string} char\n\t * @param {number} index\n\t * @return {boolean}\n\t */\n\tPattern.prototype.isValidAtIndex = function isValidAtIndex(char, index) {\n\t  return this.formatCharacters[this.pattern[index]].validate(char)\n\t}\n\t\n\tPattern.prototype.transform = function transform(char, index) {\n\t  var format = this.formatCharacters[this.pattern[index]]\n\t  return typeof format.transform == 'function' ? format.transform(char) : char\n\t}\n\t\n\tfunction InputMask(options) {\n\t  if (!(this instanceof InputMask)) { return new InputMask(options) }\n\t  options = extend({\n\t    formatCharacters: null,\n\t    pattern: null,\n\t    isRevealingMask: false,\n\t    placeholderChar: DEFAULT_PLACEHOLDER_CHAR,\n\t    selection: {start: 0, end: 0},\n\t    value: ''\n\t  }, options)\n\t\n\t  if (options.pattern == null) {\n\t    throw new Error('InputMask: you must provide a pattern.')\n\t  }\n\t\n\t  if (typeof options.placeholderChar !== 'string' || options.placeholderChar.length > 1) {\n\t    throw new Error('InputMask: placeholderChar should be a single character or an empty string.')\n\t  }\n\t\n\t  this.placeholderChar = options.placeholderChar\n\t  this.formatCharacters = mergeFormatCharacters(options.formatCharacters)\n\t  this.setPattern(options.pattern, {\n\t    value: options.value,\n\t    selection: options.selection,\n\t    isRevealingMask: options.isRevealingMask\n\t  })\n\t}\n\t\n\t// Editing\n\t\n\t/**\n\t * Applies a single character of input based on the current selection.\n\t * @param {string} char\n\t * @return {boolean} true if a change has been made to value or selection as a\n\t *   result of the input, false otherwise.\n\t */\n\tInputMask.prototype.input = function input(char) {\n\t  // Ignore additional input if the cursor's at the end of the pattern\n\t  if (this.selection.start === this.selection.end &&\n\t      this.selection.start === this.pattern.length) {\n\t    return false\n\t  }\n\t\n\t  var selectionBefore = copy(this.selection)\n\t  var valueBefore = this.getValue()\n\t\n\t  var inputIndex = this.selection.start\n\t\n\t  // If the cursor or selection is prior to the first editable character, make\n\t  // sure any input given is applied to it.\n\t  if (inputIndex < this.pattern.firstEditableIndex) {\n\t    inputIndex = this.pattern.firstEditableIndex\n\t  }\n\t\n\t  // Bail out or add the character to input\n\t  if (this.pattern.isEditableIndex(inputIndex)) {\n\t    if (!this.pattern.isValidAtIndex(char, inputIndex)) {\n\t      return false\n\t    }\n\t    this.value[inputIndex] = this.pattern.transform(char, inputIndex)\n\t  }\n\t\n\t  // If multiple characters were selected, blank the remainder out based on the\n\t  // pattern.\n\t  var end = this.selection.end - 1\n\t  while (end > inputIndex) {\n\t    if (this.pattern.isEditableIndex(end)) {\n\t      this.value[end] = this.placeholderChar\n\t    }\n\t    end--\n\t  }\n\t\n\t  // Advance the cursor to the next character\n\t  this.selection.start = this.selection.end = inputIndex + 1\n\t\n\t  // Skip over any subsequent static characters\n\t  while (this.pattern.length > this.selection.start &&\n\t         !this.pattern.isEditableIndex(this.selection.start)) {\n\t    this.selection.start++\n\t    this.selection.end++\n\t  }\n\t\n\t  // History\n\t  if (this._historyIndex != null) {\n\t    // Took more input after undoing, so blow any subsequent history away\n\t    this._history.splice(this._historyIndex, this._history.length - this._historyIndex)\n\t    this._historyIndex = null\n\t  }\n\t  if (this._lastOp !== 'input' ||\n\t      selectionBefore.start !== selectionBefore.end ||\n\t      this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n\t    this._history.push({value: valueBefore, selection: selectionBefore, lastOp: this._lastOp})\n\t  }\n\t  this._lastOp = 'input'\n\t  this._lastSelection = copy(this.selection)\n\t\n\t  return true\n\t}\n\t\n\t/**\n\t * Attempts to delete from the value based on the current cursor position or\n\t * selection.\n\t * @return {boolean} true if the value or selection changed as the result of\n\t *   backspacing, false otherwise.\n\t */\n\tInputMask.prototype.backspace = function backspace() {\n\t  // If the cursor is at the start there's nothing to do\n\t  if (this.selection.start === 0 && this.selection.end === 0) {\n\t    return false\n\t  }\n\t\n\t  var selectionBefore = copy(this.selection)\n\t  var valueBefore = this.getValue()\n\t\n\t  // No range selected - work on the character preceding the cursor\n\t  if (this.selection.start === this.selection.end) {\n\t    if (this.pattern.isEditableIndex(this.selection.start - 1)) {\n\t      this.value[this.selection.start - 1] = this.placeholderChar\n\t    }\n\t    this.selection.start--\n\t    this.selection.end--\n\t  }\n\t  // Range selected - delete characters and leave the cursor at the start of the selection\n\t  else {\n\t    var end = this.selection.end - 1\n\t    while (end >= this.selection.start) {\n\t      if (this.pattern.isEditableIndex(end)) {\n\t        this.value[end] = this.placeholderChar\n\t      }\n\t      end--\n\t    }\n\t    this.selection.end = this.selection.start\n\t  }\n\t\n\t  // History\n\t  if (this._historyIndex != null) {\n\t    // Took more input after undoing, so blow any subsequent history away\n\t    this._history.splice(this._historyIndex, this._history.length - this._historyIndex)\n\t  }\n\t  if (this._lastOp !== 'backspace' ||\n\t      selectionBefore.start !== selectionBefore.end ||\n\t      this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n\t    this._history.push({value: valueBefore, selection: selectionBefore, lastOp: this._lastOp})\n\t  }\n\t  this._lastOp = 'backspace'\n\t  this._lastSelection = copy(this.selection)\n\t\n\t  return true\n\t}\n\t\n\t/**\n\t * Attempts to paste a string of input at the current cursor position or over\n\t * the top of the current selection.\n\t * Invalid content at any position will cause the paste to be rejected, and it\n\t * may contain static parts of the mask's pattern.\n\t * @param {string} input\n\t * @return {boolean} true if the paste was successful, false otherwise.\n\t */\n\tInputMask.prototype.paste = function paste(input) {\n\t  // This is necessary because we're just calling input() with each character\n\t  // and rolling back if any were invalid, rather than checking up-front.\n\t  var initialState = {\n\t    value: this.value.slice(),\n\t    selection: copy(this.selection),\n\t    _lastOp: this._lastOp,\n\t    _history: this._history.slice(),\n\t    _historyIndex: this._historyIndex,\n\t    _lastSelection: copy(this._lastSelection)\n\t  }\n\t\n\t  // If there are static characters at the start of the pattern and the cursor\n\t  // or selection is within them, the static characters must match for a valid\n\t  // paste.\n\t  if (this.selection.start < this.pattern.firstEditableIndex) {\n\t    for (var i = 0, l = this.pattern.firstEditableIndex - this.selection.start; i < l; i++) {\n\t      if (input.charAt(i) !== this.pattern.pattern[i]) {\n\t        return false\n\t      }\n\t    }\n\t\n\t    // Continue as if the selection and input started from the editable part of\n\t    // the pattern.\n\t    input = input.substring(this.pattern.firstEditableIndex - this.selection.start)\n\t    this.selection.start = this.pattern.firstEditableIndex\n\t  }\n\t\n\t  for (i = 0, l = input.length;\n\t       i < l && this.selection.start <= this.pattern.lastEditableIndex;\n\t       i++) {\n\t    var valid = this.input(input.charAt(i))\n\t    // Allow static parts of the pattern to appear in pasted input - they will\n\t    // already have been stepped over by input(), so verify that the value\n\t    // deemed invalid by input() was the expected static character.\n\t    if (!valid) {\n\t      if (this.selection.start > 0) {\n\t        // XXX This only allows for one static character to be skipped\n\t        var patternIndex = this.selection.start - 1\n\t        if (!this.pattern.isEditableIndex(patternIndex) &&\n\t            input.charAt(i) === this.pattern.pattern[patternIndex]) {\n\t          continue\n\t        }\n\t      }\n\t      extend(this, initialState)\n\t      return false\n\t    }\n\t  }\n\t\n\t  return true\n\t}\n\t\n\t// History\n\t\n\tInputMask.prototype.undo = function undo() {\n\t  // If there is no history, or nothing more on the history stack, we can't undo\n\t  if (this._history.length === 0 || this._historyIndex === 0) {\n\t    return false\n\t  }\n\t\n\t  var historyItem\n\t  if (this._historyIndex == null) {\n\t    // Not currently undoing, set up the initial history index\n\t    this._historyIndex = this._history.length - 1\n\t    historyItem = this._history[this._historyIndex]\n\t    // Add a new history entry if anything has changed since the last one, so we\n\t    // can redo back to the initial state we started undoing from.\n\t    var value = this.getValue()\n\t    if (historyItem.value !== value ||\n\t        historyItem.selection.start !== this.selection.start ||\n\t        historyItem.selection.end !== this.selection.end) {\n\t      this._history.push({value: value, selection: copy(this.selection), lastOp: this._lastOp, startUndo: true})\n\t    }\n\t  }\n\t  else {\n\t    historyItem = this._history[--this._historyIndex]\n\t  }\n\t\n\t  this.value = historyItem.value.split('')\n\t  this.selection = historyItem.selection\n\t  this._lastOp = historyItem.lastOp\n\t  return true\n\t}\n\t\n\tInputMask.prototype.redo = function redo() {\n\t  if (this._history.length === 0 || this._historyIndex == null) {\n\t    return false\n\t  }\n\t  var historyItem = this._history[++this._historyIndex]\n\t  // If this is the last history item, we're done redoing\n\t  if (this._historyIndex === this._history.length - 1) {\n\t    this._historyIndex = null\n\t    // If the last history item was only added to start undoing, remove it\n\t    if (historyItem.startUndo) {\n\t      this._history.pop()\n\t    }\n\t  }\n\t  this.value = historyItem.value.split('')\n\t  this.selection = historyItem.selection\n\t  this._lastOp = historyItem.lastOp\n\t  return true\n\t}\n\t\n\t// Getters & setters\n\t\n\tInputMask.prototype.setPattern = function setPattern(pattern, options) {\n\t  options = extend({\n\t    selection: {start: 0, end: 0},\n\t    value: ''\n\t  }, options)\n\t  this.pattern = new Pattern(pattern, this.formatCharacters, this.placeholderChar, options.isRevealingMask)\n\t  this.setValue(options.value)\n\t  this.emptyValue = this.pattern.formatValue([]).join('')\n\t  this.selection = options.selection\n\t  this._resetHistory()\n\t}\n\t\n\tInputMask.prototype.setSelection = function setSelection(selection) {\n\t  this.selection = copy(selection)\n\t  if (this.selection.start === this.selection.end) {\n\t    if (this.selection.start < this.pattern.firstEditableIndex) {\n\t      this.selection.start = this.selection.end = this.pattern.firstEditableIndex\n\t      return true\n\t    }\n\t    // Set selection to the first editable, non-placeholder character before the selection\n\t    // OR to the beginning of the pattern\n\t    var index = this.selection.start\n\t    while (index >= this.pattern.firstEditableIndex) {\n\t      if (this.pattern.isEditableIndex(index - 1) &&\n\t          this.value[index - 1] !== this.placeholderChar ||\n\t          index === this.pattern.firstEditableIndex) {\n\t        this.selection.start = this.selection.end = index\n\t        break\n\t      }\n\t      index--\n\t    }\n\t    return true\n\t  }\n\t  return false\n\t}\n\t\n\tInputMask.prototype.setValue = function setValue(value) {\n\t  if (value == null) {\n\t    value = ''\n\t  }\n\t  this.value = this.pattern.formatValue(value.split(''))\n\t}\n\t\n\tInputMask.prototype.getValue = function getValue() {\n\t  return this.value.join('')\n\t}\n\t\n\tInputMask.prototype.getRawValue = function getRawValue() {\n\t  var rawValue = []\n\t  for (var i = 0; i < this.value.length; i++) {\n\t    if (this.pattern._editableIndices[i] === true) {\n\t      rawValue.push(this.value[i])\n\t    }\n\t  }\n\t  return rawValue.join('')\n\t}\n\t\n\tInputMask.prototype._resetHistory = function _resetHistory() {\n\t  this._history = []\n\t  this._historyIndex = null\n\t  this._lastOp = null\n\t  this._lastSelection = copy(this.selection)\n\t}\n\t\n\tInputMask.Pattern = Pattern\n\t\n\tmodule.exports = InputMask\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** react-maskedinput.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 3abc07daad89752d2f2d\n **/","var React = require('react')\nvar InputMask = require('inputmask-core')\n\nvar KEYCODE_Z = 90\nvar KEYCODE_Y = 89\n\nfunction isUndo(e) {\n  return (e.ctrlKey || e.metaKey) && e.keyCode === (e.shiftKey ? KEYCODE_Y : KEYCODE_Z)\n}\n\nfunction isRedo(e) {\n  return (e.ctrlKey || e.metaKey) && e.keyCode === (e.shiftKey ? KEYCODE_Z : KEYCODE_Y)\n}\n\nfunction getSelection (el) {\n  var start, end, rangeEl, clone\n\n  if (el.selectionStart !== undefined) {\n    start = el.selectionStart\n    end = el.selectionEnd\n  }\n  else {\n    try {\n      el.focus()\n      rangeEl = el.createTextRange()\n      clone = rangeEl.duplicate()\n\n      rangeEl.moveToBookmark(document.selection.createRange().getBookmark())\n      clone.setEndPoint('EndToStart', rangeEl)\n\n      start = clone.text.length\n      end = start + rangeEl.text.length\n    }\n    catch (e) { /* not focused or not visible */ }\n  }\n\n  return { start, end }\n}\n\nfunction setSelection(el, selection) {\n  var rangeEl\n\n  try {\n    if (el.selectionStart !== undefined) {\n      el.focus()\n      el.setSelectionRange(selection.start, selection.end)\n    }\n    else {\n      el.focus()\n      rangeEl = el.createTextRange()\n      rangeEl.collapse(true)\n      rangeEl.moveStart('character', selection.start)\n      rangeEl.moveEnd('character', selection.end - selection.start)\n      rangeEl.select()\n    }\n  }\n  catch (e) { /* not focused or not visible */ }\n}\n\nvar MaskedInput = React.createClass({\n  propTypes: {\n    mask: React.PropTypes.string.isRequired,\n\n    formatCharacters: React.PropTypes.object,\n    placeholderChar: React.PropTypes.string\n  },\n\n  getDefaultProps() {\n    return {\n      value: ''\n    }\n  },\n\n  componentWillMount() {\n    var options = {\n      pattern: this.props.mask,\n      value: this.props.value,\n      formatCharacters: this.props.formatCharacters\n    }\n    if (this.props.placeholderChar) {\n      options.placeholderChar = this.props.placeholderChar\n    }\n    this.mask = new InputMask(options)\n  },\n\n  componentWillReceiveProps(nextProps) {\n    if (this.props.mask !== nextProps.mask && this.props.value !== nextProps.mask) {\n      // if we get a new value and a new mask at the same time\n      // check if the mask.value is still the initial value\n      // - if so use the nextProps value\n      // - otherwise the `this.mask` has a value for us (most likely from paste action)\n      if (this.mask.getValue() === this.mask.emptyValue) {\n        this.mask.setPattern(nextProps.mask, {value: nextProps.value})\n      }\n      else {\n        this.mask.setPattern(nextProps.mask, {value: this.mask.getRawValue()})\n      }\n    }\n    else if (this.props.mask !== nextProps.mask) {\n      this.mask.setPattern(nextProps.mask, {value: this.mask.getRawValue()})\n    }\n    else if (this.props.value !== nextProps.value) {\n      this.mask.setValue(nextProps.value)\n    }\n  },\n\n  componentWillUpdate(nextProps, nextState) {\n    if (nextProps.mask !== this.props.mask) {\n      this._updatePattern(nextProps)\n    }\n  },\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.mask !== this.props.mask && this.mask.selection.start) {\n      this._updateInputSelection()\n    }\n  },\n\n  _updatePattern: function(props) {\n    this.mask.setPattern(props.mask, {\n      value: this.mask.getRawValue(),\n      selection: getSelection(this.input)\n    })\n  },\n\n  _updateMaskSelection() {\n    this.mask.selection = getSelection(this.input)\n  },\n\n  _updateInputSelection() {\n    setSelection(this.input, this.mask.selection)\n  },\n\n  _onChange(e) {\n    // console.log('onChange', JSON.stringify(getSelection(this.input)), e.target.value)\n\n    var maskValue = this.mask.getValue()\n    if (e.target.value !== maskValue) {\n      // Cut or delete operations will have shortened the value\n      if (e.target.value.length < maskValue.length) {\n        var sizeDiff = maskValue.length - e.target.value.length\n        this._updateMaskSelection()\n        this.mask.selection.end = this.mask.selection.start + sizeDiff\n        this.mask.backspace()\n      }\n      var value = this._getDisplayValue()\n      e.target.value = value\n      if (value) {\n        this._updateInputSelection()\n      }\n    }\n    if (this.props.onChange) {\n      this.props.onChange(e)\n    }\n  },\n\n  _onKeyDown(e) {\n    // console.log('onKeyDown', JSON.stringify(getSelection(this.input)), e.key, e.target.value)\n\n    if (isUndo(e)) {\n      e.preventDefault()\n      if (this.mask.undo()) {\n        e.target.value = this._getDisplayValue()\n        this._updateInputSelection()\n        if (this.props.onChange) {\n          this.props.onChange(e)\n        }\n      }\n      return\n    }\n    else if (isRedo(e)) {\n      e.preventDefault()\n      if (this.mask.redo()) {\n        e.target.value = this._getDisplayValue()\n        this._updateInputSelection()\n        if (this.props.onChange) {\n          this.props.onChange(e)\n        }\n      }\n      return\n    }\n\n    if (e.key === 'Backspace') {\n      e.preventDefault()\n      this._updateMaskSelection()\n      if (this.mask.backspace()) {\n        var value = this._getDisplayValue()\n        e.target.value = value\n        if (value) {\n          this._updateInputSelection()\n        }\n        if (this.props.onChange) {\n          this.props.onChange(e)\n        }\n      }\n    }\n  },\n\n  _onKeyPress(e) {\n    // console.log('onKeyPress', JSON.stringify(getSelection(this.input)), e.key, e.target.value)\n\n    // Ignore modified key presses\n    // Ignore enter key to allow form submission\n    if (e.metaKey || e.altKey || e.ctrlKey || e.key === 'Enter') { return }\n\n    e.preventDefault()\n    this._updateMaskSelection()\n    if (this.mask.input((e.key || e.data))) {\n      e.target.value = this.mask.getValue()\n      this._updateInputSelection()\n      if (this.props.onChange) {\n        this.props.onChange(e)\n      }\n    }\n  },\n\n  _onPaste(e) {\n    // console.log('onPaste', JSON.stringify(getSelection(this.input)), e.clipboardData.getData('Text'), e.target.value)\n\n    e.preventDefault()\n    this._updateMaskSelection()\n    // getData value needed for IE also works in FF & Chrome\n    if (this.mask.paste(e.clipboardData.getData('Text'))) {\n      e.target.value = this.mask.getValue()\n      // Timeout needed for IE\n      setTimeout(this._updateInputSelection, 0)\n      if (this.props.onChange) {\n        this.props.onChange(e)\n      }\n    }\n  },\n\n  _getDisplayValue() {\n    var value = this.mask.getValue()\n    return value === this.mask.emptyValue ? '' : value\n  },\n\n  _keyPressPropName() {\n    if (typeof navigator !== 'undefined') {\n      return navigator.userAgent.match(/Android/i)\n      ? 'onBeforeInput'\n      : 'onKeyPress'\n    }\n    return 'onKeyPress'\n  },\n\n  _getEventHandlers() {\n    return {\n      onChange: this._onChange,\n      onKeyDown: this._onKeyDown,\n      onPaste: this._onPaste,\n      [this._keyPressPropName()]: this._onKeyPress\n    }\n  },\n\n  focus() {\n    this.input.focus()\n  },\n\n  blur() {\n    this.input.blur()\n  },\n\n  render() {\n    var ref = r => this.input = r\n    var maxLength = this.mask.pattern.length\n    var value = this._getDisplayValue()\n    var eventHandlers = this._getEventHandlers()\n    var { size = maxLength, placeholder = this.mask.emptyValue } = this.props\n\n    var {placeholderChar, formatCharacters, ...cleanedProps} = this.props\n    var inputProps = { ...cleanedProps, ...eventHandlers, ref, maxLength, value, size, placeholder }\n    return <input {...inputProps} />\n  }\n})\n\nmodule.exports = MaskedInput\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","'use strict'\n\nfunction extend(dest, src) {\n  if (src) {\n    var props = Object.keys(src)\n    for (var i = 0, l = props.length; i < l ; i++) {\n      dest[props[i]] = src[props[i]]\n    }\n  }\n  return dest\n}\n\nfunction copy(obj) {\n  return extend({}, obj)\n}\n\n/**\n * Merge an object defining format characters into the defaults.\n * Passing null/undefined for en existing format character removes it.\n * Passing a definition for an existing format character overrides it.\n * @param {?Object} formatCharacters.\n */\nfunction mergeFormatCharacters(formatCharacters) {\n  var merged = copy(DEFAULT_FORMAT_CHARACTERS)\n  if (formatCharacters) {\n    var chars = Object.keys(formatCharacters)\n    for (var i = 0, l = chars.length; i < l ; i++) {\n      var char = chars[i]\n      if (formatCharacters[char] == null) {\n        delete merged[char]\n      }\n      else {\n        merged[char] = formatCharacters[char]\n      }\n    }\n  }\n  return merged\n}\n\nvar ESCAPE_CHAR = '\\\\'\n\nvar DIGIT_RE = /^\\d$/\nvar LETTER_RE = /^[A-Za-z]$/\nvar ALPHANNUMERIC_RE = /^[\\dA-Za-z]$/\n\nvar DEFAULT_PLACEHOLDER_CHAR = '_'\nvar DEFAULT_FORMAT_CHARACTERS = {\n  '*': {\n    validate: function(char) { return ALPHANNUMERIC_RE.test(char) }\n  },\n  '1': {\n    validate: function(char) { return DIGIT_RE.test(char) }\n  },\n  'a': {\n    validate: function(char) { return LETTER_RE.test(char) }\n  },\n  'A': {\n    validate: function(char) { return LETTER_RE.test(char) },\n    transform: function(char) { return char.toUpperCase() }\n  },\n  '#': {\n    validate: function(char) { return ALPHANNUMERIC_RE.test(char) },\n    transform: function(char) { return char.toUpperCase() }\n  }\n}\n\n/**\n * @param {string} source\n * @patam {?Object} formatCharacters\n */\nfunction Pattern(source, formatCharacters, placeholderChar, isRevealingMask) {\n  if (!(this instanceof Pattern)) {\n    return new Pattern(source, formatCharacters, placeholderChar)\n  }\n\n  /** Placeholder character */\n  this.placeholderChar = placeholderChar || DEFAULT_PLACEHOLDER_CHAR\n  /** Format character definitions. */\n  this.formatCharacters = formatCharacters || DEFAULT_FORMAT_CHARACTERS\n  /** Pattern definition string with escape characters. */\n  this.source = source\n  /** Pattern characters after escape characters have been processed. */\n  this.pattern = []\n  /** Length of the pattern after escape characters have been processed. */\n  this.length = 0\n  /** Index of the first editable character. */\n  this.firstEditableIndex = null\n  /** Index of the last editable character. */\n  this.lastEditableIndex = null\n  /** Lookup for indices of editable characters in the pattern. */\n  this._editableIndices = {}\n  /** If true, only the pattern before the last valid value character shows. */\n  this.isRevealingMask = isRevealingMask || false\n\n  this._parse()\n}\n\nPattern.prototype._parse = function parse() {\n  var sourceChars = this.source.split('')\n  var patternIndex = 0\n  var pattern = []\n\n  for (var i = 0, l = sourceChars.length; i < l; i++) {\n    var char = sourceChars[i]\n    if (char === ESCAPE_CHAR) {\n      if (i === l - 1) {\n        throw new Error('InputMask: pattern ends with a raw ' + ESCAPE_CHAR)\n      }\n      char = sourceChars[++i]\n    }\n    else if (char in this.formatCharacters) {\n      if (this.firstEditableIndex === null) {\n        this.firstEditableIndex = patternIndex\n      }\n      this.lastEditableIndex = patternIndex\n      this._editableIndices[patternIndex] = true\n    }\n\n    pattern.push(char)\n    patternIndex++\n  }\n\n  if (this.firstEditableIndex === null) {\n    throw new Error(\n      'InputMask: pattern \"' + this.source + '\" does not contain any editable characters.'\n    )\n  }\n\n  this.pattern = pattern\n  this.length = pattern.length\n}\n\n/**\n * @param {Array<string>} value\n * @return {Array<string>}\n */\nPattern.prototype.formatValue = function format(value) {\n  var valueBuffer = new Array(this.length)\n  var valueIndex = 0\n\n  for (var i = 0, l = this.length; i < l ; i++) {\n    if (this.isEditableIndex(i)) {\n      if (this.isRevealingMask &&\n          value.length <= valueIndex &&\n          !this.isValidAtIndex(value[valueIndex], i)) {\n        break\n      }\n      valueBuffer[i] = (value.length > valueIndex && this.isValidAtIndex(value[valueIndex], i)\n                        ? this.transform(value[valueIndex], i)\n                        : this.placeholderChar)\n      valueIndex++\n    }\n    else {\n      valueBuffer[i] = this.pattern[i]\n      // Also allow the value to contain static values from the pattern by\n      // advancing its index.\n      if (value.length > valueIndex && value[valueIndex] === this.pattern[i]) {\n        valueIndex++\n      }\n    }\n  }\n\n  return valueBuffer\n}\n\n/**\n * @param {number} index\n * @return {boolean}\n */\nPattern.prototype.isEditableIndex = function isEditableIndex(index) {\n  return !!this._editableIndices[index]\n}\n\n/**\n * @param {string} char\n * @param {number} index\n * @return {boolean}\n */\nPattern.prototype.isValidAtIndex = function isValidAtIndex(char, index) {\n  return this.formatCharacters[this.pattern[index]].validate(char)\n}\n\nPattern.prototype.transform = function transform(char, index) {\n  var format = this.formatCharacters[this.pattern[index]]\n  return typeof format.transform == 'function' ? format.transform(char) : char\n}\n\nfunction InputMask(options) {\n  if (!(this instanceof InputMask)) { return new InputMask(options) }\n  options = extend({\n    formatCharacters: null,\n    pattern: null,\n    isRevealingMask: false,\n    placeholderChar: DEFAULT_PLACEHOLDER_CHAR,\n    selection: {start: 0, end: 0},\n    value: ''\n  }, options)\n\n  if (options.pattern == null) {\n    throw new Error('InputMask: you must provide a pattern.')\n  }\n\n  if (typeof options.placeholderChar !== 'string' || options.placeholderChar.length > 1) {\n    throw new Error('InputMask: placeholderChar should be a single character or an empty string.')\n  }\n\n  this.placeholderChar = options.placeholderChar\n  this.formatCharacters = mergeFormatCharacters(options.formatCharacters)\n  this.setPattern(options.pattern, {\n    value: options.value,\n    selection: options.selection,\n    isRevealingMask: options.isRevealingMask\n  })\n}\n\n// Editing\n\n/**\n * Applies a single character of input based on the current selection.\n * @param {string} char\n * @return {boolean} true if a change has been made to value or selection as a\n *   result of the input, false otherwise.\n */\nInputMask.prototype.input = function input(char) {\n  // Ignore additional input if the cursor's at the end of the pattern\n  if (this.selection.start === this.selection.end &&\n      this.selection.start === this.pattern.length) {\n    return false\n  }\n\n  var selectionBefore = copy(this.selection)\n  var valueBefore = this.getValue()\n\n  var inputIndex = this.selection.start\n\n  // If the cursor or selection is prior to the first editable character, make\n  // sure any input given is applied to it.\n  if (inputIndex < this.pattern.firstEditableIndex) {\n    inputIndex = this.pattern.firstEditableIndex\n  }\n\n  // Bail out or add the character to input\n  if (this.pattern.isEditableIndex(inputIndex)) {\n    if (!this.pattern.isValidAtIndex(char, inputIndex)) {\n      return false\n    }\n    this.value[inputIndex] = this.pattern.transform(char, inputIndex)\n  }\n\n  // If multiple characters were selected, blank the remainder out based on the\n  // pattern.\n  var end = this.selection.end - 1\n  while (end > inputIndex) {\n    if (this.pattern.isEditableIndex(end)) {\n      this.value[end] = this.placeholderChar\n    }\n    end--\n  }\n\n  // Advance the cursor to the next character\n  this.selection.start = this.selection.end = inputIndex + 1\n\n  // Skip over any subsequent static characters\n  while (this.pattern.length > this.selection.start &&\n         !this.pattern.isEditableIndex(this.selection.start)) {\n    this.selection.start++\n    this.selection.end++\n  }\n\n  // History\n  if (this._historyIndex != null) {\n    // Took more input after undoing, so blow any subsequent history away\n    this._history.splice(this._historyIndex, this._history.length - this._historyIndex)\n    this._historyIndex = null\n  }\n  if (this._lastOp !== 'input' ||\n      selectionBefore.start !== selectionBefore.end ||\n      this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n    this._history.push({value: valueBefore, selection: selectionBefore, lastOp: this._lastOp})\n  }\n  this._lastOp = 'input'\n  this._lastSelection = copy(this.selection)\n\n  return true\n}\n\n/**\n * Attempts to delete from the value based on the current cursor position or\n * selection.\n * @return {boolean} true if the value or selection changed as the result of\n *   backspacing, false otherwise.\n */\nInputMask.prototype.backspace = function backspace() {\n  // If the cursor is at the start there's nothing to do\n  if (this.selection.start === 0 && this.selection.end === 0) {\n    return false\n  }\n\n  var selectionBefore = copy(this.selection)\n  var valueBefore = this.getValue()\n\n  // No range selected - work on the character preceding the cursor\n  if (this.selection.start === this.selection.end) {\n    if (this.pattern.isEditableIndex(this.selection.start - 1)) {\n      this.value[this.selection.start - 1] = this.placeholderChar\n    }\n    this.selection.start--\n    this.selection.end--\n  }\n  // Range selected - delete characters and leave the cursor at the start of the selection\n  else {\n    var end = this.selection.end - 1\n    while (end >= this.selection.start) {\n      if (this.pattern.isEditableIndex(end)) {\n        this.value[end] = this.placeholderChar\n      }\n      end--\n    }\n    this.selection.end = this.selection.start\n  }\n\n  // History\n  if (this._historyIndex != null) {\n    // Took more input after undoing, so blow any subsequent history away\n    this._history.splice(this._historyIndex, this._history.length - this._historyIndex)\n  }\n  if (this._lastOp !== 'backspace' ||\n      selectionBefore.start !== selectionBefore.end ||\n      this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n    this._history.push({value: valueBefore, selection: selectionBefore, lastOp: this._lastOp})\n  }\n  this._lastOp = 'backspace'\n  this._lastSelection = copy(this.selection)\n\n  return true\n}\n\n/**\n * Attempts to paste a string of input at the current cursor position or over\n * the top of the current selection.\n * Invalid content at any position will cause the paste to be rejected, and it\n * may contain static parts of the mask's pattern.\n * @param {string} input\n * @return {boolean} true if the paste was successful, false otherwise.\n */\nInputMask.prototype.paste = function paste(input) {\n  // This is necessary because we're just calling input() with each character\n  // and rolling back if any were invalid, rather than checking up-front.\n  var initialState = {\n    value: this.value.slice(),\n    selection: copy(this.selection),\n    _lastOp: this._lastOp,\n    _history: this._history.slice(),\n    _historyIndex: this._historyIndex,\n    _lastSelection: copy(this._lastSelection)\n  }\n\n  // If there are static characters at the start of the pattern and the cursor\n  // or selection is within them, the static characters must match for a valid\n  // paste.\n  if (this.selection.start < this.pattern.firstEditableIndex) {\n    for (var i = 0, l = this.pattern.firstEditableIndex - this.selection.start; i < l; i++) {\n      if (input.charAt(i) !== this.pattern.pattern[i]) {\n        return false\n      }\n    }\n\n    // Continue as if the selection and input started from the editable part of\n    // the pattern.\n    input = input.substring(this.pattern.firstEditableIndex - this.selection.start)\n    this.selection.start = this.pattern.firstEditableIndex\n  }\n\n  for (i = 0, l = input.length;\n       i < l && this.selection.start <= this.pattern.lastEditableIndex;\n       i++) {\n    var valid = this.input(input.charAt(i))\n    // Allow static parts of the pattern to appear in pasted input - they will\n    // already have been stepped over by input(), so verify that the value\n    // deemed invalid by input() was the expected static character.\n    if (!valid) {\n      if (this.selection.start > 0) {\n        // XXX This only allows for one static character to be skipped\n        var patternIndex = this.selection.start - 1\n        if (!this.pattern.isEditableIndex(patternIndex) &&\n            input.charAt(i) === this.pattern.pattern[patternIndex]) {\n          continue\n        }\n      }\n      extend(this, initialState)\n      return false\n    }\n  }\n\n  return true\n}\n\n// History\n\nInputMask.prototype.undo = function undo() {\n  // If there is no history, or nothing more on the history stack, we can't undo\n  if (this._history.length === 0 || this._historyIndex === 0) {\n    return false\n  }\n\n  var historyItem\n  if (this._historyIndex == null) {\n    // Not currently undoing, set up the initial history index\n    this._historyIndex = this._history.length - 1\n    historyItem = this._history[this._historyIndex]\n    // Add a new history entry if anything has changed since the last one, so we\n    // can redo back to the initial state we started undoing from.\n    var value = this.getValue()\n    if (historyItem.value !== value ||\n        historyItem.selection.start !== this.selection.start ||\n        historyItem.selection.end !== this.selection.end) {\n      this._history.push({value: value, selection: copy(this.selection), lastOp: this._lastOp, startUndo: true})\n    }\n  }\n  else {\n    historyItem = this._history[--this._historyIndex]\n  }\n\n  this.value = historyItem.value.split('')\n  this.selection = historyItem.selection\n  this._lastOp = historyItem.lastOp\n  return true\n}\n\nInputMask.prototype.redo = function redo() {\n  if (this._history.length === 0 || this._historyIndex == null) {\n    return false\n  }\n  var historyItem = this._history[++this._historyIndex]\n  // If this is the last history item, we're done redoing\n  if (this._historyIndex === this._history.length - 1) {\n    this._historyIndex = null\n    // If the last history item was only added to start undoing, remove it\n    if (historyItem.startUndo) {\n      this._history.pop()\n    }\n  }\n  this.value = historyItem.value.split('')\n  this.selection = historyItem.selection\n  this._lastOp = historyItem.lastOp\n  return true\n}\n\n// Getters & setters\n\nInputMask.prototype.setPattern = function setPattern(pattern, options) {\n  options = extend({\n    selection: {start: 0, end: 0},\n    value: ''\n  }, options)\n  this.pattern = new Pattern(pattern, this.formatCharacters, this.placeholderChar, options.isRevealingMask)\n  this.setValue(options.value)\n  this.emptyValue = this.pattern.formatValue([]).join('')\n  this.selection = options.selection\n  this._resetHistory()\n}\n\nInputMask.prototype.setSelection = function setSelection(selection) {\n  this.selection = copy(selection)\n  if (this.selection.start === this.selection.end) {\n    if (this.selection.start < this.pattern.firstEditableIndex) {\n      this.selection.start = this.selection.end = this.pattern.firstEditableIndex\n      return true\n    }\n    // Set selection to the first editable, non-placeholder character before the selection\n    // OR to the beginning of the pattern\n    var index = this.selection.start\n    while (index >= this.pattern.firstEditableIndex) {\n      if (this.pattern.isEditableIndex(index - 1) &&\n          this.value[index - 1] !== this.placeholderChar ||\n          index === this.pattern.firstEditableIndex) {\n        this.selection.start = this.selection.end = index\n        break\n      }\n      index--\n    }\n    return true\n  }\n  return false\n}\n\nInputMask.prototype.setValue = function setValue(value) {\n  if (value == null) {\n    value = ''\n  }\n  this.value = this.pattern.formatValue(value.split(''))\n}\n\nInputMask.prototype.getValue = function getValue() {\n  return this.value.join('')\n}\n\nInputMask.prototype.getRawValue = function getRawValue() {\n  var rawValue = []\n  for (var i = 0; i < this.value.length; i++) {\n    if (this.pattern._editableIndices[i] === true) {\n      rawValue.push(this.value[i])\n    }\n  }\n  return rawValue.join('')\n}\n\nInputMask.prototype._resetHistory = function _resetHistory() {\n  this._history = []\n  this._historyIndex = null\n  this._lastOp = null\n  this._lastSelection = copy(this.selection)\n}\n\nInputMask.Pattern = Pattern\n\nmodule.exports = InputMask\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/inputmask-core/lib/index.js\n ** module id = 1\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}\n ** module id = 2\n ** module chunks = 0\n **/"],"sourceRoot":""}