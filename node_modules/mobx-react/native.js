(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("mobx"), require("react"));
	else if(typeof define === 'function' && define.amd)
		define(["mobx", "react"], factory);
	else if(typeof exports === 'object')
		exports["mobxReact"] = factory(require("mobx"), require("react"));
	else
		root["mobxReact"] = factory(root["mobx"], root["React"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.reactiveComponent = exports.PropTypes = exports.propTypes = exports.inject = exports.Provider = exports.useStaticRendering = exports.trackComponents = exports.componentByNodeRegistery = exports.renderReporter = exports.observer = undefined;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _arguments = arguments;

	var _observer = __webpack_require__(1);

	Object.defineProperty(exports, 'observer', {
	  enumerable: true,
	  get: function get() {
	    return _observer.observer;
	  }
	});
	Object.defineProperty(exports, 'renderReporter', {
	  enumerable: true,
	  get: function get() {
	    return _observer.renderReporter;
	  }
	});
	Object.defineProperty(exports, 'componentByNodeRegistery', {
	  enumerable: true,
	  get: function get() {
	    return _observer.componentByNodeRegistery;
	  }
	});
	Object.defineProperty(exports, 'trackComponents', {
	  enumerable: true,
	  get: function get() {
	    return _observer.trackComponents;
	  }
	});
	Object.defineProperty(exports, 'useStaticRendering', {
	  enumerable: true,
	  get: function get() {
	    return _observer.useStaticRendering;
	  }
	});

	var _Provider = __webpack_require__(9);

	Object.defineProperty(exports, 'Provider', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Provider).default;
	  }
	});

	var _inject = __webpack_require__(6);

	Object.defineProperty(exports, 'inject', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_inject).default;
	  }
	});

	var _mobx = __webpack_require__(2);

	var _mobx2 = _interopRequireDefault(_mobx);

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(10);

	var propTypes = _interopRequireWildcard(_propTypes);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var TARGET_LIB_NAME = void 0;
	if (false) TARGET_LIB_NAME = 'mobx-react';
	if (true) TARGET_LIB_NAME = 'mobx-react/native';
	if (false) TARGET_LIB_NAME = 'mobx-react/custom';

	if (!_mobx2.default) throw new Error(TARGET_LIB_NAME + ' requires the MobX package');
	if (!_react2.default) throw new Error(TARGET_LIB_NAME + ' requires React to be available');

	exports.propTypes = propTypes;
	exports.PropTypes = propTypes;
	exports.default = module.exports;

	/* Deprecated */

	var reactiveComponent = exports.reactiveComponent = function reactiveComponent() {
	  console.warn('[mobx-react] `reactiveComponent` has been renamed to `observer` ' + 'and will be removed in 1.1.');
	  return observer.apply(null, _arguments);
	};

	/* DevTool support */
	if ((typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ? 'undefined' : _typeof(__MOBX_DEVTOOLS_GLOBAL_HOOK__)) === 'object') {
	  __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobxReact(module.exports, _mobx2.default);
	}

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.renderReporter = exports.componentByNodeRegistery = undefined;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	exports.trackComponents = trackComponents;
	exports.useStaticRendering = useStaticRendering;
	exports.observer = observer;

	var _mobx = __webpack_require__(2);

	var _mobx2 = _interopRequireDefault(_mobx);

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(4);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _EventEmitter = __webpack_require__(5);

	var _EventEmitter2 = _interopRequireDefault(_EventEmitter);

	var _inject = __webpack_require__(6);

	var _inject2 = _interopRequireDefault(_inject);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * dev tool support
	 */
	var isDevtoolsEnabled = false;

	var isUsingStaticRendering = false;

	// WeakMap<Node, Object>;
	var componentByNodeRegistery = exports.componentByNodeRegistery = typeof WeakMap !== "undefined" ? new WeakMap() : undefined;
	var renderReporter = exports.renderReporter = new _EventEmitter2.default();

	function findDOMNode(component) {
	  if (_reactDom2.default) return _reactDom2.default.findDOMNode(component);
	  return null;
	}

	function reportRendering(component) {
	  var node = findDOMNode(component);
	  if (node && componentByNodeRegistery) componentByNodeRegistery.set(node, component);

	  renderReporter.emit({
	    event: 'render',
	    renderTime: component.__$mobRenderEnd - component.__$mobRenderStart,
	    totalTime: Date.now() - component.__$mobRenderStart,
	    component: component,
	    node: node
	  });
	}

	function trackComponents() {
	  if (typeof WeakMap === "undefined") throw new Error("[mobx-react] tracking components is not supported in this browser.");
	  if (!isDevtoolsEnabled) isDevtoolsEnabled = true;
	}

	function useStaticRendering(useStaticRendering) {
	  isUsingStaticRendering = useStaticRendering;
	}

	/**
	 * Utilities
	 */

	function patch(target, funcName) {
	  var base = target[funcName];
	  var mixinFunc = reactiveMixin[funcName];
	  if (!base) {
	    target[funcName] = mixinFunc;
	  } else {
	    target[funcName] = function () {
	      base.apply(this, arguments);
	      mixinFunc.apply(this, arguments);
	    };
	  }
	}

	/**
	 * ReactiveMixin
	 */
	var reactiveMixin = {
	  componentWillMount: function componentWillMount() {
	    var _this = this;

	    if (isUsingStaticRendering === true) return;
	    // Generate friendly name for debugging
	    var initialName = this.displayName || this.name || this.constructor && (this.constructor.displayName || this.constructor.name) || "<component>";
	    var rootNodeID = this._reactInternalInstance && this._reactInternalInstance._rootNodeID;
	    var baseRender = this.render.bind(this);
	    var reaction = null;
	    var isRenderingPending = false;

	    var initialRender = function initialRender() {
	      reaction = new _mobx2.default.Reaction(initialName + '#' + rootNodeID + '.render()', function () {
	        if (!isRenderingPending) {
	          // N.B. Getting here *before mounting* means that a component constructor has side effects (see the relevant test in misc.js)
	          // This unidiomatic React usage but React will correctly warn about this so we continue as usual
	          // See #85 / Pull #44
	          isRenderingPending = true;
	          if (typeof _this.componentWillReact === "function") _this.componentWillReact(); // TODO: wrap in action?
	          if (_this.__$mobxIsUnmounted !== true) {
	            // If we are unmounted at this point, componentWillReact() had a side effect causing the component to unmounted
	            // TODO: remove this check? Then react will properly warn about the fact that this should not happen? See #73
	            // However, people also claim this migth happen during unit tests..
	            var hasError = true;
	            try {
	              _react2.default.Component.prototype.forceUpdate.call(_this);
	              hasError = false;
	            } finally {
	              if (hasError) reaction.dispose();
	            }
	          }
	        }
	      });
	      reactiveRender.$mobx = reaction;
	      _this.render = reactiveRender;
	      return reactiveRender();
	    };

	    var reactiveRender = function reactiveRender() {
	      isRenderingPending = false;
	      var rendering = undefined;
	      reaction.track(function () {
	        if (isDevtoolsEnabled) {
	          _this.__$mobRenderStart = Date.now();
	        }
	        rendering = _mobx2.default.extras.allowStateChanges(false, baseRender);
	        if (isDevtoolsEnabled) {
	          _this.__$mobRenderEnd = Date.now();
	        }
	      });
	      return rendering;
	    };

	    this.render = initialRender;
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    if (isUsingStaticRendering === true) return;
	    this.render.$mobx && this.render.$mobx.dispose();
	    this.__$mobxIsUnmounted = true;
	    if (isDevtoolsEnabled) {
	      var node = findDOMNode(this);
	      if (node && componentByNodeRegistery) {
	        componentByNodeRegistery.delete(node);
	      }
	      renderReporter.emit({
	        event: 'destroy',
	        component: this,
	        node: node
	      });
	    }
	  },

	  componentDidMount: function componentDidMount() {
	    if (isDevtoolsEnabled) {
	      reportRendering(this);
	    }
	  },

	  componentDidUpdate: function componentDidUpdate() {
	    if (isDevtoolsEnabled) {
	      reportRendering(this);
	    }
	  },

	  shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
	    if (isUsingStaticRendering) {
	      console.warn("[mobx-react] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side.");
	    }
	    // update on any state changes (as is the default)
	    if (this.state !== nextState) {
	      return true;
	    }
	    // update if props are shallowly not equal, inspired by PureRenderMixin
	    var keys = Object.keys(this.props);
	    if (keys.length !== Object.keys(nextProps).length) {
	      return true;
	    }
	    var key = void 0;
	    for (var i = keys.length - 1; i >= 0, key = keys[i]; i--) {
	      var newValue = nextProps[key];
	      if (newValue !== this.props[key]) {
	        return true;
	      } else if (newValue && (typeof newValue === 'undefined' ? 'undefined' : _typeof(newValue)) === "object" && !_mobx2.default.isObservable(newValue)) {
	        /**
	         * If the newValue is still the same object, but that object is not observable,
	         * fallback to the default React behavior: update, because the object *might* have changed.
	         * If you need the non default behavior, just use the React pure render mixin, as that one
	         * will work fine with mobx as well, instead of the default implementation of
	         * observer.
	         */
	        return true;
	      }
	    }
	    return false;
	  }
	};

	/**
	 * Observer function / decorator
	 */
	function observer(arg1, arg2) {
	  if (typeof arg1 === "string") {
	    throw new Error("Store names should be provided as array");
	  }
	  if (Array.isArray(arg1)) {
	    // component needs stores
	    if (!arg2) {
	      // invoked as decorator
	      return function (componentClass) {
	        return observer(arg1, componentClass);
	      };
	    } else {
	      // TODO: deprecate this invocation style
	      return _inject2.default.apply(null, arg1)(observer(arg2));
	    }
	  }
	  var componentClass = arg1;

	  if (componentClass.isInjector !== undefined && componentClass.isInjector) {
	    console.warn('Mobx Observer: You are trying to use \'observer\' on a component that already has \'inject\'. Please apply \'observer\' before applying \'inject\'');
	  }

	  // Stateless function component:
	  // If it is function but doesn't seem to be a react class constructor,
	  // wrap it to a react class automatically
	  if (typeof componentClass === "function" && (!componentClass.prototype || !componentClass.prototype.render) && !componentClass.isReactClass && !_react2.default.Component.isPrototypeOf(componentClass)) {

	    return observer(_react2.default.createClass({
	      displayName: componentClass.displayName || componentClass.name,
	      propTypes: componentClass.propTypes,
	      contextTypes: componentClass.contextTypes,
	      getDefaultProps: function getDefaultProps() {
	        return componentClass.defaultProps;
	      },
	      render: function render() {
	        return componentClass.call(this, this.props, this.context);
	      }
	    }));
	  }

	  if (!componentClass) {
	    throw new Error("Please pass a valid component to 'observer'");
	  }

	  var target = componentClass.prototype || componentClass;
	  ["componentWillMount", "componentWillUnmount", "componentDidMount", "componentDidUpdate"].forEach(function (funcName) {
	    patch(target, funcName);
	  });
	  if (!target.shouldComponentUpdate) {
	    target.shouldComponentUpdate = reactiveMixin.shouldComponentUpdate;
	  }
	  componentClass.isMobXReactObserver = true;
	  return componentClass;
	}

/***/ },
/* 2 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_2__;

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_3__;

/***/ },
/* 4 */
/***/ function(module, exports) {

	module.exports = null


/***/ },
/* 5 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var EventEmitter = function () {
	  function EventEmitter() {
	    _classCallCheck(this, EventEmitter);

	    this.listeners = [];
	  }

	  _createClass(EventEmitter, [{
	    key: "on",
	    value: function on(cb) {
	      var _this = this;

	      this.listeners.push(cb);
	      return function () {
	        var index = _this.listeners.indexOf(cb);
	        if (index !== -1) _this.listeners.splice(index, 1);
	      };
	    }
	  }, {
	    key: "emit",
	    value: function emit(data) {
	      this.listeners.forEach(function (fn) {
	        return fn(data);
	      });
	    }
	  }]);

	  return EventEmitter;
	}();

	exports.default = EventEmitter;

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = inject;

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _hoistNonReactStatics = __webpack_require__(8);

	var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Store Injection
	 */
	function createStoreInjector(grabStoresFn, component) {
	  var Injector = _react2.default.createClass({
	    displayName: "MobXStoreInjector",
	    render: function render() {
	      var _this = this;

	      var newProps = {};
	      for (var key in this.props) {
	        if (this.props.hasOwnProperty(key)) {
	          newProps[key] = this.props[key];
	        }
	      }var additionalProps = grabStoresFn(this.context.mobxStores || {}, newProps, this.context) || {};
	      for (var _key in additionalProps) {
	        newProps[_key] = additionalProps[_key];
	      }
	      newProps.ref = function (instance) {
	        _this.wrappedInstance = instance;
	      };

	      return _react2.default.createElement(component, newProps);
	    }
	    // TODO: should have shouldComponentUpdate?
	  });

	  Injector.isInjector = true;
	  Injector.contextTypes = { mobxStores: _react.PropTypes.object };
	  Injector.wrappedComponent = component;
	  injectStaticWarnings(Injector, component);
	  (0, _hoistNonReactStatics2.default)(Injector, component);
	  return Injector;
	}

	function injectStaticWarnings(hoc, component) {
	  if (typeof process === "undefined" || !process.env || process.env.NODE_ENV === "production") return;

	  ['propTypes', 'defaultProps', 'contextTypes'].forEach(function (prop) {
	    var propValue = hoc[prop];
	    Object.defineProperty(hoc, prop, {
	      set: function set(_) {
	        // enable for testing:
	        var name = component.displayName || component.name;
	        console.warn('Mobx Injector: you are trying to attach ' + prop + ' to HOC instead of ' + name + '. Use `wrappedComponent` property.');
	      },
	      get: function get() {
	        return propValue;
	      },
	      configurable: true
	    });
	  });
	}

	function grabStoresByName(storeNames) {
	  return function (baseStores, nextProps) {
	    storeNames.forEach(function (storeName) {
	      if (storeName in nextProps) // prefer props over stores
	        return;
	      if (!(storeName in baseStores)) throw new Error("MobX observer: Store '" + storeName + "' is not available! Make sure it is provided by some Provider");
	      nextProps[storeName] = baseStores[storeName];
	    });
	    return nextProps;
	  };
	}

	/**
	 * higher order component that injects stores to a child.
	 * takes either a varargs list of strings, which are stores read from the context,
	 * or a function that manually maps the available stores from the context to props:
	 * storesToProps(mobxStores, props, context) => newProps
	 */
	function inject() /* fn(stores, nextProps) or ...storeNames */{
	  var grabStoresFn = void 0;
	  if (typeof arguments[0] === "function") {
	    grabStoresFn = arguments[0];
	  } else {
	    var storesNames = [];
	    for (var i = 0; i < arguments.length; i++) {
	      storesNames[i] = arguments[i];
	    }grabStoresFn = grabStoresByName(storesNames);
	  }
	  return function (componentClass) {
	    return createStoreInjector(grabStoresFn, componentClass);
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ },
/* 7 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	(function () {
	    try {
	        cachedSetTimeout = setTimeout;
	    } catch (e) {
	        cachedSetTimeout = function () {
	            throw new Error('setTimeout is not defined');
	        }
	    }
	    try {
	        cachedClearTimeout = clearTimeout;
	    } catch (e) {
	        cachedClearTimeout = function () {
	            throw new Error('clearTimeout is not defined');
	        }
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        return setTimeout(fun, 0);
	    } else {
	        return cachedSetTimeout.call(null, fun, 0);
	    }
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        clearTimeout(marker);
	    } else {
	        cachedClearTimeout.call(null, marker);
	    }
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 8 */
/***/ function(module, exports) {

	/**
	 * Copyright 2015, Yahoo! Inc.
	 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
	 */
	'use strict';

	var REACT_STATICS = {
	    childContextTypes: true,
	    contextTypes: true,
	    defaultProps: true,
	    displayName: true,
	    getDefaultProps: true,
	    mixins: true,
	    propTypes: true,
	    type: true
	};

	var KNOWN_STATICS = {
	    name: true,
	    length: true,
	    prototype: true,
	    caller: true,
	    arguments: true,
	    arity: true
	};

	var isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';

	module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {
	    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components
	        var keys = Object.getOwnPropertyNames(sourceComponent);

	        /* istanbul ignore else */
	        if (isGetOwnPropertySymbolsAvailable) {
	            keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));
	        }

	        for (var i = 0; i < keys.length; ++i) {
	            if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {
	                try {
	                    targetComponent[keys[i]] = sourceComponent[keys[i]];
	                } catch (error) {

	                }
	            }
	        }
	    }

	    return targetComponent;
	};


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var specialReactKeys = { children: true, key: true, ref: true };

	var Provider = function (_Component) {
	  _inherits(Provider, _Component);

	  function Provider() {
	    _classCallCheck(this, Provider);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(Provider).apply(this, arguments));
	  }

	  _createClass(Provider, [{
	    key: "render",
	    value: function render() {
	      return _react2.default.Children.only(this.props.children);
	    }
	  }, {
	    key: "getChildContext",
	    value: function getChildContext() {
	      var stores = {};
	      // inherit stores
	      var baseStores = this.context.mobxStores;
	      if (baseStores) for (var key in baseStores) {
	        stores[key] = baseStores[key];
	      }
	      // add own stores
	      for (var _key in this.props) {
	        if (!specialReactKeys[_key]) stores[_key] = this.props[_key];
	      }return {
	        mobxStores: stores
	      };
	    }
	  }, {
	    key: "componentWillReceiveProps",
	    value: function componentWillReceiveProps(nextProps) {
	      // Maybe this warning is to aggressive?
	      if (Object.keys(nextProps).length !== Object.keys(this.props).length) console.warn("MobX Provider: The set of provided stores has changed. Please avoid changing stores as the change might not propagate to all children");
	      for (var key in nextProps) {
	        if (!specialReactKeys[key] && this.props[key] !== nextProps[key]) console.warn("MobX Provider: Provided store '" + key + "' has changed. Please avoid replacing stores as the change might not propagate to all children");
	      }
	    }
	  }]);

	  return Provider;
	}(_react.Component);

	Provider.contextTypes = {
	  mobxStores: _react.PropTypes.object
	};
	Provider.childContextTypes = {
	  mobxStores: _react.PropTypes.object.isRequired
	};
	exports.default = Provider;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.objectOrObservableObject = exports.arrayOrObservableArrayOf = exports.arrayOrObservableArray = exports.observableObject = exports.observableMap = exports.observableArrayOf = exports.observableArray = undefined;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _mobx = __webpack_require__(2);

	// Copied from React.PropTypes
	function createChainableTypeChecker(validate) {
	  function checkType(isRequired, props, propName, componentName, location, propFullName) {
	    for (var _len = arguments.length, rest = Array(_len > 6 ? _len - 6 : 0), _key = 6; _key < _len; _key++) {
	      rest[_key - 6] = arguments[_key];
	    }

	    return (0, _mobx.untracked)(function () {
	      componentName = componentName || '<<anonymous>>';
	      propFullName = propFullName || propName;
	      if (props[propName] == null) {
	        if (isRequired) {
	          var actual = props[propName] === null ? 'null' : 'undefined';
	          return new Error('The ' + location + ' `' + propFullName + '` is marked as required ' + 'in `' + componentName + '`, but its value is `' + actual + '`.');
	        }
	        return null;
	      } else {
	        return validate.apply(undefined, [props, propName, componentName, location, propFullName].concat(rest));
	      }
	    });
	  }

	  var chainedCheckType = checkType.bind(null, false);
	  chainedCheckType.isRequired = checkType.bind(null, true);
	  return chainedCheckType;
	}

	// Copied from React.PropTypes
	function isSymbol(propType, propValue) {
	  // Native Symbol.
	  if (propType === 'symbol') {
	    return true;
	  }

	  // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
	  if (propValue['@@toStringTag'] === 'Symbol') {
	    return true;
	  }

	  // Fallback for non-spec compliant Symbols which are polyfilled.
	  if (typeof Symbol === 'function' && propValue instanceof Symbol) {
	    return true;
	  }

	  return false;
	}

	// Copied from React.PropTypes
	function getPropType(propValue) {
	  var propType = typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue);
	  if (Array.isArray(propValue)) {
	    return 'array';
	  }
	  if (propValue instanceof RegExp) {
	    // Old webkits (at least until Android 4.0) return 'function' rather than
	    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	    // passes PropTypes.object.
	    return 'object';
	  }
	  if (isSymbol(propType, propValue)) {
	    return 'symbol';
	  }
	  return propType;
	}

	// This handles more types than `getPropType`. Only used for error messages.
	// Copied from React.PropTypes
	function getPreciseType(propValue) {
	  var propType = getPropType(propValue);
	  if (propType === 'object') {
	    if (propValue instanceof Date) {
	      return 'date';
	    } else if (propValue instanceof RegExp) {
	      return 'regexp';
	    }
	  }
	  return propType;
	}

	function createObservableTypeCheckerCreator(allowNativeType, mobxType) {
	  return createChainableTypeChecker(function (props, propName, componentName, location, propFullName) {
	    return (0, _mobx.untracked)(function () {
	      if (allowNativeType) {
	        if (getPropType(props[propName]) === mobxType.toLowerCase()) return null;
	      }
	      var mobxChecker = void 0;
	      switch (mobxType) {
	        case 'Array':
	          mobxChecker = _mobx.isObservableArray;break;
	        case 'Object':
	          mobxChecker = _mobx.isObservableObject;break;
	        case 'Map':
	          mobxChecker = _mobx.isObservableMap;break;
	        default:
	          throw new Error('Unexpected mobxType: ' + mobxType);
	      }
	      var propValue = props[propName];
	      if (!mobxChecker(propValue)) {
	        var preciseType = getPreciseType(propValue);
	        var nativeTypeExpectationMessage = allowNativeType ? ' or javascript `' + mobxType.toLowerCase() + '`' : '';
	        return new Error('Invalid prop `' + propFullName + '` of type `' + preciseType + '` supplied to' + ' `' + componentName + '`, expected `mobx.Observable' + mobxType + '`' + nativeTypeExpectationMessage + '.');
	      }
	      return null;
	    });
	  });
	}

	function createObservableArrayOfTypeChecker(allowNativeType, typeChecker) {
	  return createChainableTypeChecker(function (props, propName, componentName, location, propFullName) {
	    for (var _len2 = arguments.length, rest = Array(_len2 > 5 ? _len2 - 5 : 0), _key2 = 5; _key2 < _len2; _key2++) {
	      rest[_key2 - 5] = arguments[_key2];
	    }

	    return (0, _mobx.untracked)(function () {
	      if (typeof typeChecker !== 'function') {
	        return new Error('Property `' + propFullName + '` of component `' + componentName + '` has ' + 'invalid PropType notation.');
	      }
	      var error = createObservableTypeCheckerCreator(allowNativeType, 'Array')(props, propName, componentName);
	      if (error instanceof Error) return error;
	      var propValue = props[propName];
	      for (var i = 0; i < propValue.length; i++) {
	        error = typeChecker.apply(undefined, [propValue, i, componentName, location, propFullName + '[' + i + ']'].concat(rest));
	        if (error instanceof Error) return error;
	      }
	      return null;
	    });
	  });
	}

	var observableArray = exports.observableArray = createObservableTypeCheckerCreator(false, 'Array');
	var observableArrayOf = exports.observableArrayOf = createObservableArrayOfTypeChecker.bind(null, false);
	var observableMap = exports.observableMap = createObservableTypeCheckerCreator(false, 'Map');
	var observableObject = exports.observableObject = createObservableTypeCheckerCreator(false, 'Object');
	var arrayOrObservableArray = exports.arrayOrObservableArray = createObservableTypeCheckerCreator(true, 'Array');
	var arrayOrObservableArrayOf = exports.arrayOrObservableArrayOf = createObservableArrayOfTypeChecker.bind(null, true);
	var objectOrObservableObject = exports.objectOrObservableObject = createObservableTypeCheckerCreator(true, 'Object');

/***/ }
/******/ ])
});
;